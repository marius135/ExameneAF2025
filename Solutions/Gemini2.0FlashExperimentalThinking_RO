Rezolvare Examen Algoritmi Fundamentali - Varianta 2
Subiectul 1: Subgraf bipartit conex maximal

Cerință: Indicați un subgraf indus bipartit conex cu număr maxim de noduri și o bipartiție a acestuia pentru Graf_1_6.

Abordare:

Înțelegerea conceptelor:

Subgraf indus: Un subgraf format dintr-un subset de noduri și toate muchiile din graful original care au ambele extremități în acest subset.

Bipartit: Un graf în care nodurile pot fi împărțite în două mulțimi disjuncte (partiții) astfel încât fiecare muchie conectează un nod dintr-o partiție cu un nod din cealaltă partiție.

Conex: Există un drum între oricare două noduri din graf.

Analiza Graf_1_6:

"Graf_1_6": {
    "Orientat": "Neorientat",
    "Noduri": ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
    "Muchii": [
        {"x": "1", "y": "2", "w": "1"},
        {"x": "2", "y": "6", "w": "10"},
        {"x": "2", "y": "3", "w": "2"},
        {"x": "1", "y": "3", "w": "4"},
        {"x": "3", "y": "6", "w": "11"},
        {"x": "3", "y": "5", "w": "12"},
        {"x": "5", "y": "4", "w": "1"},
        {"x": "3", "y": "4", "w": "5"},
        {"x": "4", "y": "8", "w": "3"},
        {"x": "8", "y": "9", "w": "6"},
        {"x": "9", "y": "7", "w": "5"},
        {"x": "7", "y": "8", "w": "2"}
    ]
}

Graful este neorientat. Să construim lista de adiacență, ținând cont de ordinea lexicografică a vecinilor:

1: [2, 3]
2: [1, 3, 6]
3: [1, 2, 4, 5, 6]
4: [3, 5, 8]
5: [3, 4]
6: [2, 3]
7: [8, 9]
8: [4, 7, 9]
9: [7, 8]
Verificarea bipartiției și construirea subgrafului:

Începem cu un nod, de exemplu '1', și îl colorăm cu culoarea 1. Vecinii săi ('2', '3') trebuie să aibă culoarea 2. Vecinii lui '2' (exceptând '1') trebuie să aibă culoarea 1, și așa mai departe. Folosim BFS pentru a colora graful și a verifica bipartiția.

Dacă întâlnim o muchie între două noduri de aceeași culoare, graful nu este bipartit. În acest caz, trebuie să eliminăm noduri pentru a obține un subgraf bipartit.

Începem BFS din nodul '1' și atribuim culori (1 și 2).

BFS pentru bipartiție începând cu nodul '1':

Nod '1': Culoare 1, Partiția 1 = {1}

Vecini ai lui '1' (în ordine lexicografică): '2', '3': Culoare 2, Partiția 2 = {2, 3}

Vecini ai lui '2' (în ordine lexicografică): '1' (deja vizitat), '3' (deja vizitat), '6': Culoare 1, Partiția 1 = {1, 6}

Vecini ai lui '3' (în ordine lexicografică): '1' (deja vizitat), '2' (deja vizitat), '4', '5', '6' (deja vizitat): Culoare 1, Partiția 1 = {1, 6, 4, 5} Conflict! '3' și '4' sunt adiacente și ar trebui să aibă culori diferite conform colorării de până acum ('3' - 2, '4' - 1). Dar și muchia (3, 4) există. Greșeala este în presupunerea că vecinii lui 3 trebuie să fie culoarea 1. Vecinii lui 3 (care are culoarea 2) trebuie să aibă culoarea 1.

Refacem BFS pentru bipartiție:

Nod '1': Culoare 1, Partiția 1 = {1}

Vecini ai lui '1': '2', '3': Culoare 2, Partiția 2 = {2, 3}

Vecini ai lui '2': '1' (vizitat), '3' (vizitat), '6': Culoare 1, Partiția 1 = {1, 6}

Vecini ai lui '3': '1' (vizitat), '2' (vizitat), '4', '5', '6' (vizitat): Culoare 1, Partiția 1 = {1, 6, 4, 5}

Vecini ai lui '6': '2' (vizitat), '3' (vizitat): Nu adăugăm vecini noi.

Vecini ai lui '4': '3' (vizitat), '5' (vizitat), '8': Culoare 2, Partiția 2 = {2, 3, 8}

Vecini ai lui '5': '3' (vizitat), '4' (vizitat): Nu adăugăm vecini noi.

Vecini ai lui '8': '4' (vizitat), '7', '9': Culoare 1, Partiția 1 = {1, 6, 4, 5, 7, 9}

Vecini ai lui '7': '8' (vizitat), '9' (vizitat): Nu adăugăm vecini noi.

Vecini ai lui '9': '7' (vizitat), '8' (vizitat): Nu adăugăm vecini noi.

Partiția 1 = {1, 6, 4, 5, 7, 9}, Partiția 2 = {2, 3, 8}

Verificăm muchiile:

(1, 2): 1-2 (Partiția 1 - Partiția 2) - OK

(2, 6): 2-6 (Partiția 2 - Partiția 1) - OK

(2, 3): 2-3 (Partiția 2 - Partiția 2) - EROARE! Muchia (2, 3) nu respectă bipartiția.

Rezolvarea conflictului: Muchia (2, 3) conectează două noduri din Partiția 2. Pentru a face graful bipartit, trebuie să eliminăm fie nodul '2' sau nodul '3' (și muchiile incidente) sau muchia (2, 3) (dar cerința este subgraf indus, deci trebuie să eliminăm noduri).

Dacă eliminăm nodul '2':

Noduri rămase: {1, 3, 4, 5, 6, 7, 8, 9}

Subgraf indus:

1: [3]
3: [1, 4, 5, 6]
4: [3, 5, 8]
5: [3, 4]
6: [3]
7: [8, 9]
8: [4, 7, 9]
9: [7, 8]


Repetăm colorarea bipartită începând cu nodul '1':

'1': Culoare 1, P1 = {1}

'3': Culoare 2, P2 = {3}

'4', '5', '6': Culoare 1, P1 = {1, 4, 5, 6}

'8': Culoare 2, P2 = {3, 8}

'7', '9': Culoare 1, P1 = {1, 4, 5, 6, 7, 9}

Partiția 1 = {1, 4, 5, 6, 7, 9}, Partiția 2 = {3, 8}. Noduri nefolosite: {2}.
Verificare muchii în subgraf:

(1, 3): 1-3 (P1-P2) - OK

(3, 6): 3-6 (P2-P1) - OK

(3, 5): 3-5 (P2-P1) - OK

(3, 4): 3-4 (P2-P1) - OK

(5, 4): 5-4 (P1-P1) - EROARE! Muchia (5, 4) nu respectă bipartiția.

Rezolvare conflictului (5, 4): Trebuie să eliminăm fie '4' fie '5'.

Dacă eliminăm nodul '4' (din subgraful fără '2'):

Noduri rămase: {1, 3, 5, 6, 7, 8, 9} (eliminat '2' și '4')

Subgraf indus:

1: [3]
3: [1, 5, 6]
5: [3]
6: [3]
7: [8, 9]
8: [7, 9]
9: [7, 8]


Colorare bipartită:

'1': Culoare 1, P1 = {1}

'3': Culoare 2, P2 = {3}

'5', '6': Culoare 1, P1 = {1, 5, 6}

'8': Culoare 2, P2 = {3, 8}

'7', '9': Culoare 1, P1 = {1, 5, 6, 7, 9}

Partiția 1 = {1, 5, 6, 7, 9}, Partiția 2 = {3, 8}. Noduri nefolosite: {2, 4}. Total noduri: 7.
Verificare muchii:

(1, 3): OK, (3, 5): OK, (3, 6): OK, (7, 8): OK, (8, 9): OK, (9, 7): OK. Bipartit și conex? Da, componenta conexă care conține '1' este {1, 3, 5, 6, 8, 7, 9}. Nodul '7' și '9' sunt conectați prin '8', '8' este conectat la '3', '3' la '1', '3' la '5' și '3' la '6'. Da, este conex.

Dacă eliminăm nodul '5' (din subgraful fără '2'):
- Noduri rămase: {1, 3, 4, 6, 7, 8, 9} (eliminat '2' și '5')
- Subgraf indus:
1: [3] 3: [1, 4, 6] 4: [3, 8] 6: [3] 7: [8, 9] 8: [4, 7, 9] 9: [7, 8]
- Colorare bipartită:
- '1': Culoare 1, P1 = {1}
- '3': Culoare 2, P2 = {3}
- '4', '6': Culoare 1, P1 = {1, 4, 6}
- '8': Culoare 2, P2 = {3, 8}
- '7', '9': Culoare 1, P1 = {1, 4, 6, 7, 9}

**Partiția 1 = {1, 4, 6, 7, 9}, Partiția 2 = {3, 8}. Noduri nefolosite: {2, 5}. Total noduri: 7.**
   **Verificare muchii:**
    - (1, 3): OK, (3, 4): OK, (3, 6): OK, (4, 8): OK, (7, 8): OK, (8, 9): OK, (9, 7): OK. **Bipartit și conex?** Da, componenta conexă care conține '1' este {1, 3, 4, 6, 8, 7, 9}. Similar, este conex.


Dacă eliminăm nodul '3' (din graful inițial):

Noduri rămase: {1, 2, 4, 5, 6, 7, 8, 9}

Subgraf indus:

1: [2]
2: [1, 6]
4: [5, 8]
5: [4]
6: [2]
7: [8, 9]
8: [4, 7, 9]
9: [7, 8]


Colorare bipartită:

'1': Culoare 1, P1 = {1}

'2': Culoare 2, P2 = {2}

'6': Culoare 1, P1 = {1, 6}

'4': Culoare 1, P1 = {1, 6, 4}

'5': Culoare 2, P2 = {2, 5}

'8': Culoare 2, P2 = {2, 5, 8}

'7', '9': Culoare 1, P1 = {1, 6, 4, 7, 9}

Partiția 1 = {1, 6, 4, 7, 9}, Partiția 2 = {2, 5, 8}. Noduri nefolosite: {3}. Total noduri: 8.
Verificare muchii:

(1, 2): OK, (2, 6): OK, (5, 4): OK, (4, 8): OK, (7, 8): OK, (8, 9): OK, (9, 7): OK. Bipartit și conex? Da, componenta conexă care conține '1' este {1, 2, 6, 5, 4, 8, 7, 9}. Da, este conex.

Subgraful bipartit conex cu cel mai mare număr de noduri găsit până acum are 8 noduri (prin eliminarea nodului '3'). Putem verifica dacă eliminarea altui nod ar duce la un subgraf mai mare sau tot de 8 noduri, sau mai mic. Însă, eliminarea nodului '3' pare a fi o alegere bună, deoarece nodul '3' participă la ciclul impar (2-3-4-5-3) și (2-3-6-2) și (1-3-2-1) și (3-4-8-7-9-8-4-3), etc.

Subgraf indus bipartit conex maximal (8 noduri): Noduri = {1, 2, 4, 5, 6, 7, 8, 9}.
Bipartiție: Partiția 1 = {1, 4, 6, 7, 9}, Partiția 2 = {2, 5, 8}.

Răspuns Subiectul 1:
Un subgraf indus bipartit conex cu număr maxim de noduri are 8 noduri. Nodurile subgrafului sunt: {1, 2, 4, 5, 6, 7, 8, 9}. Bipartiția este: Partiția 1 = {1, 4, 6, 7, 9}, Partiția 2 = {2, 5, 8}.

Subiectul 2: Parcurgerea în lățime (BFS) bf(4)

Cerință: Exemplificați parcurgerea în lățime bf(4) pentru Graf_1_6, ilustrând calculul distanțelor de la 4 și desenând arborele BFS.

Pașii BFS(4):

Inițializare:

dist[v] = ∞ pentru toate nodurile v, cu excepția dist[4] = 0.

coada = [4]

vizitat = {4}

arbore_bfs = {} (Dicționar pentru a stoca părinții în arborele BFS)

Iterație: Cât timp coada nu este goală:

Scoate nodul u din fața cozii (inițial u = 4).

Pentru fiecare vecin v al lui u în ordine lexicografică:

Dacă v nu este în vizitat:

vizitat = vizitat ∪ {v}

dist[v] = dist[u] + 1

arbore_bfs[v] = u (Setăm părintele lui v ca fiind u)

Adaugă v la coadă.

Execuție BFS(4) pe Graf_1_6:

Pas	Coadă	Nod curent u	Vecini v (ordine lexicografică)	vizitat	dist	arbore_bfs
1	[4]			{4}	d[4]=0	{}
2	[4]	4	3, 5, 8			
3	[3, 5, 8]	4	3	{4, 3}	d[3]=1	{3: 4}
4	[5, 8, 3]	4	5	{4, 3, 5}	d[5]=1	{5: 4}
5	[8, 3, 5]	4	8	{4, 3, 5, 8}	d[8]=1	{8: 4}
6	[3, 5, 8]	3	1, 2, 4 (vizitat), 5 (vizitat), 6			
7	[5, 8, 6]	3	1	{4, 3, 5, 8, 1}	d[1]=2	{3: 4, 5: 4, 8: 4, 1: 3}
8	[8, 6, 1]	3	2	{4, 3, 5, 8, 1, 2}	d[2]=2	{3: 4, 5: 4, 8: 4, 1: 3, 2: 3}
9	[6, 1, 2]	3	6	{4, 3, 5, 8, 1, 2, 6}	d[6]=2	{3: 4, 5: 4, 8: 4, 1: 3, 2: 3, 6: 3}
10	[1, 2, 6]	5	3 (vizitat), 4 (vizitat)			
11	[2, 6]	8	4 (vizitat), 7, 9			
12	[6, 7, 9]	8	7	{4, 3, 5, 8, 1, 2, 6, 7}	d[7]=2	{3: 4, 5: 4, 8: 4, 1: 3, 2: 3, 6: 3, 7: 8}
13	[7, 9]	8	9	{4, 3, 5, 8, 1, 2, 6, 7, 9}	d[9]=2	{3: 4, 5: 4, 8: 4, 1: 3, 2: 3, 6: 3, 7: 8, 9: 8}
14	[9]	6	2 (vizitat), 3 (vizitat)			
15	[]	1	2 (vizitat), 3 (vizitat)			
16	[]	2	1 (vizitat), 3 (vizitat), 6 (vizitat)			
17	[]	7	8 (vizitat), 9 (vizitat)			
18	[]	9	7 (vizitat), 8 (vizitat)			

Rezultate BFS(4):

Distanțe de la nodul '4':

d[4] = 0

d[3] = 1, d[5] = 1, d[8] = 1

d[1] = 2, d[2] = 2, d[6] = 2, d[7] = 2, d[9] = 2

d[v] = ∞ pentru nodurile nevizitate (în acest caz, toate nodurile sunt vizitate).

Arborele BFS (relații părinte-copil):

4 -> 3, 4 -> 5, 4 -> 8

3 -> 1, 3 -> 2, 3 -> 6

8 -> 7, 8 -> 9

Arbore BFS desenat (descriere textuală):

    4
   /|\
  3 5  8
 /|\   / \
1 2 6   7 9


Răspuns Subiectul 2:

Parcurgerea în lățime bf(4) începe din nodul 4. Distanțele calculate sunt: d(4)=0, d(3)=1, d(5)=1, d(8)=1, d(1)=2, d(2)=2, d(6)=2, d(7)=2, d(9)=2. Arborele BFS este descris mai sus, având rădăcina în nodul 4 și muchiile determinate de relațiile părinte-copil stabilite în timpul parcurgerii.

Subiectul 3: Lanț Eulerian

Cerință: Admite graful Graf_1_6 un lanț eulerian? Dacă nu, eliminați un număr minim de muchii pentru a-l obține, descriind strategia, și indicați un lanț eulerian în graful obținut. Enunțați condiția necesară și suficientă pentru existența unui lanț eulerian într-un graf neorientat.

Condiție necesară și suficientă pentru existența unui lanț eulerian într-un graf neorientat conex: Un graf neorientat conex are un lanț eulerian dacă și numai dacă are cel mult două noduri de grad impar.

Verificăm gradele nodurilor în Graf_1_6:

grad(1) = 2

grad(2) = 3 (impar)

grad(3) = 5 (impar)

grad(4) = 3 (impar)

grad(5) = 2

grad(6) = 2

grad(7) = 2

grad(8) = 3 (impar)

grad(9) = 2

Număr de noduri cu grad impar: 4 (nodurile 2, 3, 4, 8). Deoarece sunt 4 noduri cu grad impar, graful nu admite un lanț eulerian.

Eliminarea minimă de muchii: Pentru a avea un lanț eulerian, trebuie să reducem numărul de noduri de grad impar la 0 sau 2. Fiecare muchie conectează două noduri, deci eliminarea unei muchii reduce gradul a două noduri cu 1. Dorim să împerechem nodurile de grad impar și să eliminăm muchii pentru a le face de grad par.

Nodurile de grad impar sunt {2, 3, 4, 8}. Putem împerechea (2, 3) și (4, 8).

Opțiunea 1: Eliminăm muchia (2, 3).

Grade noi:

grad(1) = 2

grad(2) = 2 (par)

grad(3) = 4 (par)

grad(4) = 3 (impar)

grad(5) = 2

grad(6) = 2

grad(7) = 2

grad(8) = 3 (impar)

grad(9) = 2

Noduri de grad impar: {4, 8} - sunt 2 noduri de grad impar. Graful obținut (după eliminarea muchiei (2, 3)) are un lanț eulerian.

Opțiunea 2: Eliminăm muchia (4, 8).

Grade noi:

grad(1) = 2

grad(2) = 3 (impar)

grad(3) = 5 (impar)

grad(4) = 2 (par)

grad(5) = 2

grad(6) = 2

grad(7) = 2

grad(8) = 2 (par)

grad(9) = 2

Noduri de grad impar: {2, 3} - sunt 2 noduri de grad impar. Graful obținut (după eliminarea muchiei (4, 8)) are un lanț eulerian.

Ambele opțiuni elimină o singură muchie și reduc numărul de noduri de grad impar la 2. Eliminarea unei muchii este numărul minim posibil, deoarece trebuie să facem un număr par de noduri de grad impar să devină par. Eliminăm muchia (2, 3).

Lanț eulerian în graful obținut după eliminarea muchiei (2, 3):

Graful modificat are muchiile:

[{"x": "1", "y": "2", "w": "1"}, {"x": "2", "y": "6", "w": "10"}, {"x": "1", "y": "3", "w": "4"}, {"x": "3", "y": "6", "w": "11"}, {"x": "3", "y": "5", "w": "12"}, {"x": "5", "y": "4", "w": "1"}, {"x": "3", "y": "4", "w": "5"}, {"x": "4", "y": "8", "w": "3"}, {"x": "8", "y": "9", "w": "6"}, {"x": "9", "y": "7", "w": "5"}, {"x": "7", "y": "8", "w": "2"}]
content_copy
download
Use code with caution.

Grade: grad(2)=2, grad(3)=4, grad(4)=3, grad(8)=3. Noduri de grad impar: {4, 8}. Lanțul eulerian trebuie să înceapă într-unul din nodurile de grad impar (4 sau 8) și să se termine în celălalt.

Găsim un lanț eulerian începând din nodul 4 (folosind algoritmul Fleury, de exemplu):

Începem din 4. Vecini: [3, 5, 8]. Alegem 3 (prima în ordine lexicografică). Drum: 4-3. Muchii rămase incidente lui 4: [(4, 5), (4, 8)]. Muchii incidente lui 3: [(3, 1), (3, 6), (3, 5)].

Nod curent 3. Vecini: [1, 5, 6]. Alegem 1. Drum: 4-3-1. Muchii incidente lui 3 rămase: [(3, 5), (3, 6)]. Muchii incidente lui 1 rămase: [(1, 2)].

Nod curent 1. Vecini: [2]. Alegem 2. Drum: 4-3-1-2. Muchii incidente lui 1 rămase: []. Muchii incidente lui 2 rămase: [(2, 6)].

Nod curent 2. Vecini: [6]. Alegem 6. Drum: 4-3-1-2-6. Muchii incidente lui 2 rămase: []. Muchii incidente lui 6 rămase: [(6, 3)].

Nod curent 6. Vecini: [3]. Alegem 3. Drum: 4-3-1-2-6-3. Muchii incidente lui 6 rămase: []. Muchii incidente lui 3 rămase: [(3, 5)].

Nod curent 3. Vecini: [5]. Alegem 5. Drum: 4-3-1-2-6-3-5. Muchii incidente lui 3 rămase: []. Muchii incidente lui 5 rămase: [(5, 4)].

Nod curent 5. Vecini: [4]. Alegem 4. Drum: 4-3-1-2-6-3-5-4. Muchii incidente lui 5 rămase: []. Muchii incidente lui 4 rămase: [(4, 8)].

Nod curent 4. Vecini: [8]. Alegem 8. Drum: 4-3-1-2-6-3-5-4-8. Muchii incidente lui 4 rămase: []. Muchii incidente lui 8 rămase: [(8, 7), (8, 9)].

Nod curent 8. Vecini: [7, 9]. Alegem 7. Drum: 4-3-1-2-6-3-5-4-8-7. Muchii incidente lui 8 rămase: [(8, 9)]. Muchii incidente lui 7 rămase: [(7, 9)].

Nod curent 7. Vecini: [9]. Alegem 9. Drum: 4-3-1-2-6-3-5-4-8-7-9. Muchii incidente lui 7 rămase: []. Muchii incidente lui 9 rămase: [(9, 8)].

Nod curent 9. Vecini: [8]. Alegem 8. Drum: 4-3-1-2-6-3-5-4-8-7-9-8. Muchii incidente lui 9 rămase: []. Muchii incidente lui 8 rămase: [].

Lanțul eulerian este: 4-3-1-2-6-3-5-4-8-7-9-8.

Răspuns Subiectul 3:

Graful Graf_1_6 nu admite un lanț eulerian deoarece are 4 noduri de grad impar (2, 3, 4, 8). Eliminând muchia (2, 3), graful obținut are exact două noduri de grad impar (4 și 8) și admite un lanț eulerian. Un lanț eulerian în graful obținut (după eliminarea muchiei (2, 3)) este: 4-3-1-2-6-3-5-4-8-7-9-8. Condiția necesară și suficientă pentru ca un graf neorientat conex să aibă un lanț eulerian este să aibă cel mult două noduri de grad impar.

Subiectul 4: Noduri critice (Articulation Points)

Cerință: Descrieți un algoritm eficient pentru nodurile critice și exemplificați-l pentru Graf_1_6.

Algoritm eficient (Tarjan's Algorithm) pentru noduri critice:

Algoritmul folosește o parcurgere DFS și menține două valori pentru fiecare nod u:

disc[u] (discovery time): timpul când nodul u este vizitat prima dată în DFS.

low[u] (low-link value): cel mai mic timp de descoperire al unui nod v care este accesibil din subarborele lui u (inclusiv u însuși) prin cel mult o muchie de întoarcere (back-edge).

Un nod u este punct critic dacă:

u este rădăcina DFS și are mai mult de un copil.

u nu este rădăcina DFS și există un copil v al lui u astfel încât low[v] ≥ disc[u].

Pașii algoritmului:

Inițializați disc[u] = -1 și low[u] = -1 pentru toate nodurile u.

Inițializați time = 0.

Pentru fiecare nod u nevizitat: Dacă disc[u] == -1, apelează DFS-AP(u, părinte = NIL).

Funcția DFS-AP(u, părinte):

disc[u] = low[u] = ++time.

copii_radacina = 0.

Pentru fiecare vecin v al lui u în ordine lexicografică:

Dacă v nu este vizitat (disc[v] == -1):

copii_radacina++ (dacă u este rădăcina)

DFS-AP(v, u)

low[u] = min(low[u], low[v])

Dacă părinte != NIL și low[v] ≥ disc[u], atunci u este punct critic.

Altfel dacă v != părinte (și v este vizitat, deci muchie de întoarcere):

low[u] = min(low[u], disc[v])

Dacă părinte == NIL și copii_radacina > 1, atunci u este punct critic (rădăcina DFS cu mai mult de un copil).

Exemplificare pentru Graf_1_6 pornind de la nodul '1':

Nod u	părinte	disc[u]	low[u]	Vecini v (ordine lexicografică)	disc[v]	low[v]	Condiție AP (pentru u)	Punct critic?
1	NIL	1	1	2	-1			
2	1	2	2	1 (părinte), 3	1, -1			
3	2	3	3	1 (părinte), 2 (părinte), 4	1, 2, -1			
4	3	4	4	3 (părinte), 5	3, -1			
5	4	5	5	3	3			
				3 (back-edge)		low[3]=3	low[5] = min(low[5], disc[3]) = min(5, 3) = 3	low[4] = min(low[4], low[5]) = min(4, 3) = 3
			3	4 (părinte)				
							low[3] = min(low[3], low[4]) = min(3, 3) = 3	low[2] = min(low[2], low[3]) = min(2, 3) = 2
				6	-1			
6	3	6	6	2	2			
				2 (back-edge)		low[2]=2	low[6] = min(low[6], disc[2]) = min(6, 2) = 2	low[3] = min(low[3], low[6]) = min(3, 2) = 2
			2	3 (părinte)				
							low[2] = min(low[2], low[3]) = min(2, 2) = 2	low[1] = min(low[1], low[2]) = min(1, 2) = 1
				3 (vecin de la 1)	3		low[1] = min(low[1], disc[3]) = min(1, 3) = 1	
8	4	7	7	4 (părinte), 7	4, -1			
7	8	8	8	8 (părinte), 9	7, -1			
9	7	9	9	7 (părinte), 8	8, 7			
				8 (back-edge)		low[8]=7	low[9] = min(low[9], disc[8]) = min(9, 7) = 7	low[7] = min(low[7], low[9]) = min(8, 7) = 7
			7	7 (părinte)				
							low[8] = min(low[8], low[7]) = min(7, 7) = 7	low[4] = min(low[4], low[8]) = min(4, 7) = 4

Calculul final low și disc valori:

Nod	disc	low
1	1	1
2	2	2
3	3	2
4	4	3
5	5	3
6	6	2
7	8	7
8	7	7
9	9	7

Verificare condiții pentru puncte critice:

Nod 1 (rădăcină): Copii în DFS arbore: {2, 3}. Are 2 copii (> 1). Nodul 1 este punct critic.

Nod 2: Copil 3. low[3] = 2, disc[2] = 2. low[3] ≥ disc[2]. Nodul 2 este punct critic.

Nod 3: Copil 4, 6. low[4] = 3, disc[3] = 3. low[4] ≥ disc[3]. Nodul 3 este punct critic. ; low[6] = 2 < disc[3], deci nu prin copilul 6. Dar prin copilul 4 este.

Nod 4: Copil 5, 8. low[5] = 3 < disc[4]. low[8] = 7 ≥ disc[4]. low[8] ≥ disc[4]. Nodul 4 este punct critic.

Nod 5: Copil 3. low[3] = 2 < disc[5]. Nu este punct critic.

Nod 6: Nu are copii în arborele DFS. Nu este punct critic.

Nod 7: Copil 9. low[9] = 7 < disc[7]. Nu este punct critic.

Nod 8: Copil 7. low[7] = 7 < disc[8]. Nu este punct critic.

Nod 9: Nu are copii în arborele DFS. Nu este punct critic.

Noduri critice identificate: {1, 2, 3, 4}.

Răspuns Subiectul 4:

Un algoritm eficient pentru determinarea nodurilor critice este algoritmul lui Tarjan bazat pe DFS, care are complexitatea O(V+E). Aplicând algoritmul pentru Graf_1_6, nodurile critice identificate sunt: {1, 2, 3, 4}.

Subiectul 5: Algoritmul Floyd-Warshall

Cerință: Descrieți algoritmul Floyd-Warshall și detaliați modificările matricei distanțelor D pentru graful Graf_1_6 la etapele j=1, j=2, j=3.

Descrierea Algoritmului Floyd-Warshall:

Algoritmul Floyd-Warshall este un algoritm pentru a găsi cele mai scurte căi între toate perechile de noduri într-un graf ponderat. Funcționează chiar și cu ponderi negative, dar nu în cazul ciclurilor negative. Pentru un graf cu n noduri, algoritmul folosește programare dinamică pentru a calcula distanțele.

Inițializare:

Se creează o matrice de distanțe D de dimensiune n x n, unde n este numărul de noduri.

D[i][j] se inițializează cu:

w(i, j) (greutatea muchiei de la nodul i la nodul j) dacă există muchie între i și j.

0 dacă i == j.

∞ (infinit) dacă i != j și nu există muchie între i și j.

Iterație:

Pentru fiecare nod j de la 1 la n (nod intermediar):

Pentru fiecare nod i de la 1 la n (nod sursă):

Pentru fiecare nod k de la 1 la n (nod destinație):

D[i][k] = min(D[i][k], D[i][j] + D[j][k])

Aplicăm Floyd-Warshall pentru Graf_1_6:

Matricea de costuri inițială D (etapa j=0):

Nodurile sunt {1, 2, 3, 4, 5, 6, 7, 8, 9}. Vom folosi indici de la 1 la 9.

1  2  3  4  5  6  7  8  9
1   0  1  4  ∞  ∞  ∞  ∞  ∞  ∞
2   1  0  2  ∞  ∞  10 ∞  ∞  ∞
3   4  2  0  5  12 11 ∞  ∞  ∞
4   ∞  ∞  5  0  1  ∞  ∞  3  ∞
5   ∞  ∞  12 1  0  ∞  ∞  ∞  ∞
6   ∞  10 11 ∞  ∞  0  ∞  ∞  ∞
7   ∞  ∞  ∞  ∞  ∞  ∞  0  2  5
8   ∞  ∞  ∞  3  ∞  ∞  2  0  6
9   ∞  ∞  ∞  ∞  ∞  ∞  5  6  0


Etapa j=1 (nod intermediar 1):

Pentru fiecare pereche (i, k), verificăm dacă D[i][k] > D[i][1] + D[1][k].

D[2][3] = min(D[2][3], D[2][1] + D[1][3]) = min(2, 1 + 4) = 2 (nu se schimbă)

D[3][2] = min(D[3][2], D[3][1] + D[1][2]) = min(2, 4 + 1) = 2 (nu se schimbă)

Matricea D după etapa j=1 rămâne neschimbată în acest caz, deoarece nu există căi mai scurte prin nodul 1 decât cele directe (sau infinite).

Etapa j=2 (nod intermediar 2):

Pentru fiecare pereche (i, k), verificăm dacă D[i][k] > D[i][2] + D[2][k].

D[1][3] = min(D[1][3], D[1][2] + D[2][3]) = min(4, 1 + 2) = 3 MODIFICAT!

D[1][6] = min(D[1][6], D[1][2] + D[2][6]) = min(∞, 1 + 10) = 11 MODIFICAT!

D[3][1] = min(D[3][1], D[3][2] + D[2][1]) = min(4, 2 + 1) = 3 MODIFICAT!

D[3][6] = min(D[3][6], D[3][2] + D[2][6]) = min(11, 2 + 10) = 12 (nu se schimbă)

D[6][1] = min(D[6][1], D[6][2] + D[2][1]) = min(∞, 10 + 1) = 11 MODIFICAT!

D[6][3] = min(D[6][3], D[6][2] + D[2][3]) = min(11, 10 + 2) = 12 (nu se schimbă)

Matricea D după etapa j=2:

1  2  3  4  5  6  7  8  9
1   0  1  3  ∞  ∞  11 ∞  ∞  ∞
2   1  0  2  ∞  ∞  10 ∞  ∞  ∞
3   3  2  0  5  12 11 ∞  ∞  ∞
4   ∞  ∞  5  0  1  ∞  ∞  3  ∞
5   ∞  ∞  12 1  0  ∞  ∞  ∞  ∞
6   11 10 12 ∞  ∞  0  ∞  ∞  ∞
7   ∞  ∞  ∞  ∞  ∞  ∞  0  2  5
8   ∞  ∞  ∞  3  ∞  ∞  2  0  6
9   ∞  ∞  ∞  ∞  ∞  ∞  5  6  0

Etapa j=3 (nod intermediar 3):

Pentru fiecare pereche (i, k), verificăm dacă D[i][k] > D[i][3] + D[3][k].

D[1][2] = min(D[1][2], D[1][3] + D[3][2]) = min(1, 3 + 2) = 1 (nu se schimbă)

D[1][4] = min(D[1][4], D[1][3] + D[3][4]) = min(∞, 3 + 5) = 8 MODIFICAT!

D[1][5] = min(D[1][5], D[1][3] + D[3][5]) = min(∞, 3 + 12) = 15 MODIFICAT!

D[1][6] = min(D[1][6], D[1][3] + D[3][6]) = min(11, 3 + 11) = 11 (nu se schimbă)

D[2][1] = min(D[2][1], D[2][3] + D[3][1]) = min(1, 2 + 3) = 1 (nu se schimbă)

D[2][4] = min(D[2][4], D[2][3] + D[3][4]) = min(∞, 2 + 5) = 7 MODIFICAT!

D[2][5] = min(D[2][5], D[2][3] + D[3][5]) = min(∞, 2 + 12) = 14 MODIFICAT!

D[2][6] = min(D[2][6], D[2][3] + D[3][6]) = min(10, 2 + 11) = 10 (nu se schimbă)

D[4][1] = min(D[4][1], D[4][3] + D[3][1]) = min(∞, 5 + 3) = 8 MODIFICAT!

D[4][2] = min(D[4][2], D[4][3] + D[3][2]) = min(∞, 5 + 2) = 7 MODIFICAT!

D[4][6] = min(D[4][6], D[4][3] + D[3][6]) = min(∞, 5 + 11) = 16 MODIFICAT!

D[5][1] = min(D[5][1], D[5][3] + D[3][1]) = min(∞, 12 + 3) = 15 MODIFICAT!

D[5][2] = min(D[5][2], D[5][3] + D[3][2]) = min(∞, 12 + 2) = 14 MODIFICAT!

D[5][6] = min(D[5][6], D[5][3] + D[3][6]) = min(∞, 12 + 11) = 23 MODIFICAT!

D[6][4] = min(D[6][4], D[6][3] + D[3][4]) = min(∞, 12 + 5) = 17 MODIFICAT!

D[6][5] = min(D[6][5], D[6][3] + D[3][5]) = min(∞, 12 + 12) = 24 MODIFICAT!

Matricea D după etapa j=3:

1  2  3  4  5  6  7  8  9
1   0  1  3  8  15 11 ∞  ∞  ∞
2   1  0  2  7  14 10 ∞  ∞  ∞
3   3  2  0  5  12 11 ∞  ∞  ∞
4   8  7  5  0  1  16 ∞  3  ∞
5   15 14 12 1  0  23 ∞  ∞  ∞
6   11 10 12 17 24 0  ∞  ∞  ∞
7   ∞  ∞  ∞  ∞  ∞  ∞  0  2  5
8   ∞  ∞  ∞  3  ∞  ∞  2  0  6
9   ∞  ∞  ∞  ∞  ∞  ∞  5  6  0


Răspuns Subiectul 5:

Algoritmul Floyd-Warshall calculează distanțele minime între toate perechile de noduri. Matricea de distanțe inițială este matricea costurilor. Matricea D se modifică la etapele j=1, j=2, j=3 conform actualizărilor descrise mai sus. Matricea D după etapa j=1 nu se modifică față de cea inițială. Matricea D după etapa j=2 și j=3 sunt prezentate mai sus, marcând valorile modificate.

Subiectul 6: Algoritmul lui Prim

Cerință: Exemplificați pașii algoritmului lui Prim pentru Graf_1_6 pornind din vârful 4.

Pașii Algoritmului lui Prim (pornind din nodul 4):

Inițializare:

MST_muchii = [] (set muchii APM - Arbore Parțial de Cost Minim)

noduri_MST = {4} (set noduri în APM)

muchii_frontiera = {} (dicționar muchii posibile de adăugat, cheie: nod din MST, valoare: (nod_extern, cost))

Iterație: Cât timp noduri_MST conține mai puțin de |V| noduri:

Găsește muchia de cost minim din muchii_frontiera. Fie (u, v) muchia de cost minim, unde u ∈ noduri_MST și v ∉ noduri_MST.

Adaugă muchia (u, v) la MST_muchii.

Adaugă nodul v la noduri_MST.

Actualizează muchii_frontiera: pentru fiecare vecin w al lui v care nu este în noduri_MST, adaugă sau actualizează muchii_frontiera[v] = (w, cost(v, w)) dacă costul este mai mic decât costul existent pentru destinația w.

Execuție Prim pornind din nodul 4:

Pas	noduri_MST	MST_muchii	muchii_frontiera (nod_MST -> (nod_extern, cost))	Muchia adăugată
1	{4}	[]	{4: [(3, 5), (5, 1), (8, 3)]} (vecinii lui 4 în ordine lexicografică)	(4, 5) cost 1
2	{4, 5}	[(4, 5)]	{4: [(3, 5), (8, 3)], 5: [(3, 12)]} (vecinii lui 5)	(5, 4) deja în MST, (5, 3) cost 12; selectăm (4, 8) cost 3
3	{4, 5, 8}	[(4, 5), (4, 8)]	{4: [(3, 5)], 5: [(3, 12)], 8: [(7, 2), (9, 6)]} (vecinii lui 8)	(8, 4) deja în MST, (8, 7) cost 2, (8, 9) cost 6; selectăm (8, 7) cost 2
4	{4, 5, 8, 7}	[(4, 5), (4, 8), (8, 7)]	{4: [(3, 5)], 5: [(3, 12)], 8: [(9, 6)], 7: [(9, 5)]} (vecinii lui 7)	(7, 8) deja în MST, (7, 9) cost 5; selectăm (7, 9) cost 5
5	{4, 5, 8, 7, 9}	[(4, 5), (4, 8), (8, 7), (7, 9)]	{4: [(3, 5)], 5: [(3, 12)], 8: [], 7: [], 9: []} (vecinii lui 9)	(9, 8) deja în MST, (9, 7) deja în MST; muchii din frontiera curentă: {4->3 cost 5, 5->3 cost 12}. Selectăm (4, 3) cost 5
6	{4, 5, 8, 7, 9, 3}	[(4, 5), (4, 8), (8, 7), (7, 9), (4, 3)]	{4: [], 5: [], 8: [], 7: [], 9: [], 3: [(1, 4), (2, 2), (6, 11)]} (vecinii lui 3)	(3, 4) deja în MST, (3, 1) cost 4, (3, 2) cost 2, (3, 6) cost 11; selectăm (3, 2) cost 2
7	{4, 5, 8, 7, 9, 3, 2}	[(4, 5), (4, 8), (8, 7), (7, 9), (4, 3), (3, 2)]	{4: [], 5: [], 8: [], 7: [], 9: [], 3: [(1, 4), (6, 11)], 2: [(1, 1), (6, 10)]} (vecinii lui 2)	(2, 3) deja în MST, (2, 1) cost 1, (2, 6) cost 10; selectăm (2, 1) cost 1
8	{4, 5, 8, 7, 9, 3, 2, 1}	[(4, 5), (4, 8), (8, 7), (7, 9), (4, 3), (3, 2), (2, 1)]	{4: [], 5: [], 8: [], 7: [], 9: [], 3: [(6, 11)], 2: [(6, 10)], 1: []} (vecinii lui 1)	(1, 2) deja în MST, (1, 3) deja în MST; muchii rămase: {3->6 cost 11, 2->6 cost 10}. Selectăm (2, 6) cost 10
9	{4, 5, 8, 7, 9, 3, 2, 1, 6}	[(4, 5), (4, 8), (8, 7), (7, 9), (4, 3), (3, 2), (2, 1), (2, 6)]	{4: [], 5: [], 8: [], 7: [], 9: [], 3: [], 2: [], 1: [], 6: []} (vecinii lui 6)	Toate nodurile sunt în MST. Algoritmul se termină.

Muchiile APM obținut: {(4, 5), (4, 8), (8, 7), (7, 9), (4, 3), (3, 2), (2, 1), (2, 6)}.

Costul total APM: 1 + 3 + 2 + 5 + 5 + 2 + 1 + 10 = 29.

Răspuns Subiectul 6:

Pașii algoritmului lui Prim pornind din vârful 4 sunt exemplificați în tabelul de mai sus. Arborele parțial de cost minim obținut este format din muchiile: {(4, 5), (4, 8), (8, 7), (7, 9), (4, 3), (3, 2), (2, 1), (2, 6)}. Costul total al APM este 29.

Subiectul 7: Corectitudinea algoritmului MST

Cerință: Este corect algoritmul dat pentru APM? Justificați fără a apela la alte algoritmi, folosind rezultate demonstrate.

Algoritmul propus:

T = (V, E = ∅)
pentru i = 1, |V|-1
  Alege componenta conexă C al lui T care conține vârful i
  Alege o muchie de cost minim e cu o extremitate în C și cealaltă nu și adaugă e la T

Justificare corectitudine:

Algoritmul propus este corect. Demonstrația se bazează pe proprietatea tăieturii pentru APM.

Proprietatea tăieturii: Pentru orice tăietură (S, V-S) într-un graf conex ponderat, dacă o muchie e este de cost minim dintre toate muchiile care traversează tăietura (adică au o extremitate în S și cealaltă în V-S), atunci există un APM care include muchia e.

Demonstrația corectitudinii algoritmului propus:

În fiecare iterație i, algoritmul alege componenta conexă C care conține vârful i. Considerăm tăietura (C, V-C). Algoritmul selectează o muchie e de cost minim cu o extremitate în C și cealaltă în V-C. Conform proprietății tăieturii, există un APM care include muchia e. Algoritmul adaugă muchia e la arborele parțial T.

La început, T nu are muchii, și fiecare nod este o componentă conexă separată. În fiecare pas, algoritmul adaugă o muchie care conectează o componentă conexă cu restul grafului, asigurându-se că graful T rămâne aciclic (deoarece adaugă muchii între componente conexe distincte). După |V|-1 iterații, algoritmul va adăuga |V|-1 muchii. Dacă graful inițial este conex, atunci T va fi un arbore parțial conex cu |V|-1 muchii, deci un arbore parțial de acoperire.

Deoarece în fiecare pas se adaugă o muchie de cost minim care traversează o tăietură, algoritmul construiește un APM. Putem argumenta prin inducție că la fiecare pas, setul de muchii selectate până acum poate fi extins la un APM. Pasul de bază (0 muchii) este trivial. Presupunem că primele k muchii selectate formează un subgraf care poate fi extins la un APM. La pasul k+1, algoritmul alege o muchie de cost minim care traversează o tăietură. Conform proprietății tăieturii, această muchie poate fi adăugată la APM-ul existent.

Concluzie: Algoritmul este corect deoarece în fiecare pas adaugă o muchie sigură (conform proprietății tăieturii) la arborele parțial în construcție, asigurând că la final se obține un APM.

Răspuns Subiectul 7:

Da, algoritmul este corect. Justificarea se bazează pe proprietatea tăieturii pentru arbori parțiali de cost minim. În fiecare iterație, algoritmul alege o muchie de cost minim care traversează o tăietură definită de o componentă conexă în arborele parțial construit până în acel moment și restul nodurilor. Conform proprietății tăieturii, o astfel de muchie poate fi inclusă într-un arbore parțial de cost minim. Prin adăugarea a |V|-1 astfel de muchii, se construiește un arbore parțial de cost minim.

Subiectul 8: Algoritmul Ford-Fulkerson (Edmonds-Karp)

Cerință: Aplicați Edmonds-Karp pe Graf_8 pornind de la fluxul indicat, găsiți tăietură minimă și capacitatea ei.

Rețeaua de transport Graf_8:

"Graf_8": {
"Orientat": "Orientat",
"Noduri": ["1", "2", "3", "4", "5", "6", "7"],
"Muchii": [
{"x": "1", "y": "2", "c": "5", "w": "10"},  // f/c format: f(e)/c(e)
{"x": "1", "y": "5", "c": "6", "w": "6"},
{"x": "4", "y": "2", "c": "3", "w": "3"},
{"x": "5", "y": "4", "c": "0", "w": "3"},
{"x": "6", "y": "4", "c": "3", "w": "5"},
{"x": "2", "y": "6", "c": "8", "w": "9"},
{"x": "3", "y": "6", "c": "3", "w": "3"},
{"x": "5", "y": "3", "c": "6", "w": "7"},
{"x": "6", "y": "7", "c": "8", "w": "10"},
{"x": "3", "y": "7", "c": "3", "w": "7"}
]
}

Flux inițial (din imagine - presupunem valorile flux/capacitate):

(1, 2): 4/5

(1, 5): 4/6

(4, 2): 2/3

(5, 4): 0/0 (flux 0, capacitate 0? - probabil eroare în date, presupunem c(5, 4) = 3, f(5, 4) = 0)

(6, 4): 2/3

(2, 6): 4/8

(3, 6): 1/3

(5, 3): 4/6

(6, 7): 7/8

(3, 7): 1/3

Sursa s=1, Destinația t=7.

Iterații Edmonds-Karp:

Iterația 1:

Graf rezidual:

(1, 2): capacitate reziduală = 5-4 = 1 (direcție înainte), (2, 1): capacitate reziduală = 4 (direcție înapoi)

(1, 5): capacitate reziduală = 6-4 = 2 (direcție înainte), (5, 1): capacitate reziduală = 4 (direcție înapoi)

(4, 2): capacitate reziduală = 3-2 = 1 (direcție înainte), (2, 4): capacitate reziduală = 2 (direcție înapoi)

(5, 4): capacitate reziduală = 3-0 = 3 (direcție înainte), (4, 5): capacitate reziduală = 0 (direcție înapoi)

(6, 4): capacitate reziduală = 3-2 = 1 (direcție înainte), (4, 6): capacitate reziduală = 2 (direcție înapoi)

(2, 6): capacitate reziduală = 8-4 = 4 (direcție înainte), (6, 2): capacitate reziduală = 4 (direcție înapoi)

(3, 6): capacitate reziduală = 3-1 = 2 (direcție înainte), (6, 3): capacitate reziduală = 1 (direcție înapoi)

(5, 3): capacitate reziduală = 6-4 = 2 (direcție înainte), (3, 5): capacitate reziduală = 4 (direcție înapoi)

(6, 7): capacitate reziduală = 8-7 = 1 (direcție înainte), (7, 6): capacitate reziduală = 7 (direcție înapoi)

(3, 7): capacitate reziduală = 3-1 = 2 (direcție înainte), (7, 3): capacitate reziduală = 1 (direcție înapoi)

BFS pentru drum s-t de lungime minimă (de la 1 la 7):

1 -> 2 (reziduală 1), 1 -> 5 (reziduală 2)

2 -> 6 (reziduală 4), 2 -> 4 (reziduală 2)

5 -> 3 (reziduală 2), 5 -> 4 (reziduală 3)

4 -> 2 (reziduală 2), 4 -> 6 (reziduală 2)

3 -> 6 (reziduală 2), 3 -> 7 (reziduală 2), 3 -> 5 (reziduală 4)

6 -> 4 (reziduală 2), 6 -> 7 (reziduală 1), 6 -> 2 (reziduală 4), 6 -> 3 (reziduală 1)

7 - destinație găsită.

Drum s-t de lungime minimă găsit (BFS): 1 -> 2 -> 6 -> 7. Lungime 3.

Capacitate minimă reziduală pe drum: min(r(1, 2), r(2, 6), r(6, 7)) = min(1, 4, 1) = 1.

Augmentăm fluxul cu 1 pe drumul 1-2-6-7:

f(1, 2) = 4 + 1 = 5

f(2, 6) = 4 + 1 = 5

f(6, 7) = 7 + 1 = 8

Iterația 2:

Graf rezidual actualizat:

(1, 2): capacitate reziduală = 5-5 = 0, (2, 1): capacitate reziduală = 5

(1, 5): capacitate reziduală = 2, (5, 1): capacitate reziduală = 4

(4, 2): capacitate reziduală = 1, (2, 4): capacitate reziduală = 2

(5, 4): capacitate reziduală = 3, (4, 5): capacitate reziduală = 0

(6, 4): capacitate reziduală = 1, (4, 6): capacitate reziduală = 2

(2, 6): capacitate reziduală = 8-5 = 3, (6, 2): capacitate reziduală = 5

(3, 6): capacitate reziduală = 2, (6, 3): capacitate reziduală = 1

(5, 3): capacitate reziduală = 2, (3, 5): capacitate reziduală = 4

(6, 7): capacitate reziduală = 8-8 = 0, (7, 6): capacitate reziduală = 8

(3, 7): capacitate reziduală = 2, (7, 3): capacitate reziduală = 1

BFS pentru drum s-t de lungime minimă:

1 -> 5 (reziduală 2)

5 -> 3 (reziduală 2)

3 -> 7 (reziduală 2)

Drum s-t de lungime minimă găsit: 1 -> 5 -> 3 -> 7. Lungime 3.

Capacitate minimă reziduală pe drum: min(r(1, 5), r(5, 3), r(3, 7)) = min(2, 2, 2) = 2.

Augmentăm fluxul cu 2 pe drumul 1-5-3-7:

f(1, 5) = 4 + 2 = 6

f(5, 3) = 4 + 2 = 6

f(3, 7) = 1 + 2 = 3

Iterația 3:

Graf rezidual actualizat:

(1, 2): capacitate reziduală = 0, (2, 1): capacitate reziduală = 5

(1, 5): capacitate reziduală = 6-6 = 0, (5, 1): capacitate reziduală = 6

(4, 2): capacitate reziduală = 1, (2, 4): capacitate reziduală = 2

(5, 4): capacitate reziduală = 3, (4, 5): capacitate reziduală = 0

(6, 4): capacitate reziduală = 1, (4, 6): capacitate reziduală = 2

(2, 6): capacitate reziduală = 3, (6, 2): capacitate reziduală = 5

(3, 6): capacitate reziduală = 2, (6, 3): capacitate reziduală = 1

(5, 3): capacitate reziduală = 6-6 = 0, (3, 5): capacitate reziduală = 6

(6, 7): capacitate reziduală = 0, (7, 6): capacitate reziduală = 8

(3, 7): capacitate reziduală = 3-3 = 0, (7, 3): capacitate reziduală = 3

BFS pentru drum s-t de lungime minimă:

1 -> 2 (blocat, reziduală 0), 1 -> 5 (blocat, reziduală 0). Niciun drum s-t găsit.

Flux maxim atins. Valoarea fluxului maxim = flux inițial + suma augmentărilor = (4+4+2+0+2+4+1+4+7+1) + 1 + 2 = (29) + 3 = 32? Valoarea fluxului este suma fluxurilor care ies din sursa: f(1, 2) + f(1, 5) = 5 + 6 = 11.

Tăietură minimă:

S = {1} (noduri accesibile din sursă în graful rezidual final)
V-S = {2, 3, 4, 5, 6, 7}

Arce directe care traversează tăietura (S către V-S):

(1, 2): capacitate 5, flux 5 (saturat)

(1, 5): capacitate 6, flux 6 (saturat)

Arce inverse care traversează tăietura (V-S către S): Niciunul.

Capacitatea tăieturii: Suma capacităților arcelor directe = c(1, 2) + c(1, 5) = 5 + 6 = 11.

Valoarea fluxului maxim = Capacitatea tăieturii minime = 11.

Tăietura minimă: (S, V-S), unde S = {1}, V-S = {2, 3, 4, 5, 6, 7}.

Vârfuri în partiția S: {1}

Vârfuri în partiția V-S: {2, 3, 4, 5, 6, 7}

Arce directe care traversează tăietura: (1, 2), (1, 5)

Arce inverse care traversează tăietura: Niciunul.

Capacitatea tăieturii: c(1, 2) + c(1, 5) = 5 + 6 = 11.

Justificare: Algoritmul Edmonds-Karp se oprește când nu mai există drumuri de augmentare de la sursă la destinație în graful rezidual. În acest moment, conform teoremei max-flux min-cut, fluxul curent este maxim, iar capacitatea tăieturii determinate de nodurile accesibile din sursă în graful rezidual este egală cu fluxul maxim și este minimă.

Răspuns Subiectul 8:

Pașii algoritmului Edmonds-Karp sunt ilustrați mai sus. Fluxul maxim obținut este 11. O tăietură minimă este (S, V-S) cu S = {1} și V-S = {2, 3, 4, 5, 6, 7}. Arcele directe care definesc capacitatea tăieturii sunt (1, 2) și (1, 5), cu capacitățile 5 și 6. Capacitatea tăieturii minime este 11. Algoritmul se oprește deoarece nu mai există drumuri de augmentare în graful rezidual, conform teoremei max-flux min-cut, acest flux este maxim și tăietura este minimă.

Subiectul 9: Probleme de teorie a grafurilor

9a) Arătați că un graf cu n>2 noduri cu d(x) >= n/2 pentru orice nod x este conex.

Demonstrație: Presupunem prin contradicție că graful G nu este conex. Atunci G are cel puțin două componente conexe, fie C1 și C2. Fie nodul x în C1. Toți vecinii lui x trebuie să fie și ei în C1, altfel ar exista o muchie între C1 și C2, contrazicând definiția componentelor conexe.

Fie |C1| = k. Atunci, numărul de noduri în C2 și restul componentelor este n - k. Deoarece C1 este o componentă conexă, niciun nod din C1 nu este adiacent cu un nod din afara lui C1 (adică în C2 sau alte componente). Deci, toți vecinii lui x trebuie să fie în C1. Numărul maxim de vecini pe care x îi poate avea în C1 este |C1| - 1 = k - 1 (dacă x este conectat la toate celelalte noduri din C1). Deci, gradul maxim al lui x este d(x) ≤ k - 1.

De asemenea, deoarece C2 este nevidă, avem k ≤ n - 1, deci k - 1 < n - 1. Din ipoteză, d(x) >= n/2. Deci, k - 1 >= d(x) >= n/2. De aici, k - 1 >= n/2, deci k >= n/2 + 1.

Dar, suma nodurilor din toate componentele conexe trebuie să fie n. Dacă avem cel puțin două componente, atunci |C1| + |C2| + ... = n. Știm că |C1| = k >= n/2 + 1. Pentru ca graful să fie deconectat, trebuie să existe cel puțin o altă componentă C2. Dacă C2 este nevidă, atunci |C2| >= 1. Deci, |C1| + |C2| >= (n/2 + 1) + 1 = n/2 + 2. Dacă n > 2, atunci n/2 + 2 > n/2 + 1.

Fie k = |C1|. Atunci numărul de noduri în V-C1 este n-k. Pentru orice nod x în C1, toți vecinii lui x sunt în C1. Deci, d(x) <= k-1. Din ipoteză, d(x) >= n/2. Deci, k-1 >= n/2 => k >= n/2 + 1. Similar, pentru orice nod y în C2, d(y) <= (n-k) - 1. Din ipoteză, d(y) >= n/2. Deci, (n-k) - 1 >= n/2 => n - k >= n/2 + 1 => k <= n - (n/2 + 1) = n/2 - 1.

Avem k >= n/2 + 1 și k <= n/2 - 1. Acest lucru este imposibil pentru n > 2. Contradicție. Prin urmare, presupunerea inițială că graful nu este conex este falsă. Graful este conex.

9b) Exemplu de graf nehamiltonian cu două noduri neadiacente x, y cu d(x) + d(y) >= n.

Exemplu: Graful bipartit complet K_{1, 3}. Noduri: {a, b, c, d}, Muchii: {(a, b), (a, c), (a, d)}.

n = 4.

Grade: d(a) = 3, d(b) = 1, d(c) = 1, d(d) = 1.

Nu este hamiltonian deoarece nu are ciclu hamiltonian (începând din b, c sau d, trebuie să ajungi la a, dar apoi nu mai poți reveni la b, c sau d fără a repeta a).

Alege nodurile neadiacente b și c. d(b) + d(c) = 1 + 1 = 2. n = 4. d(b) + d(c) = 2 < n = 4. Nu funcționează.

Modificăm K_{1, 3} să funcționeze: Adăugăm un nod și conexiuni.
Graf cu 5 noduri. Noduri {v1, v2, v3, v4, v5}. Muchii: {(v1, v2), (v1, v3), (v1, v4)}. Adăugăm nod v5. Conectăm v5 la v2 și v3.
Muchii: {(v1, v2), (v1, v3), (v1, v4), (v5, v2), (v5, v3)}.
Grade: d(v1) = 3, d(v2) = 2, d(v3) = 2, d(v4) = 1, d(v5) = 2. n = 5.
Noduri neadiacente: v4 și v5. d(v4) + d(v5) = 1 + 2 = 3 < n = 5. Nu încă.

Încercăm Petersen Graph: Este nehamiltonian, are 10 noduri, grad 3 pentru fiecare nod. Pentru orice două noduri neadiacente x, y, d(x) + d(y) = 3 + 3 = 6 < n = 10. Nu funcționează.

Considerăm graf bipartit complet K_{r, s}. Pentru a fi nehamiltonian, trebuie să aibă partițiile inegale (r != s). K_{2, 3}. n = 5. Partiții {A, B}, |A| = 2, |B| = 3. Nu are ciclu hamiltonian. Alege nod x din A și y din A (neadiacente). Nu există noduri neadiacente în aceeași partiție în K_{r,s}. Trebuie să alegem x din A și y din B. Dar sunt adiacente.

Exemplu Graf Nehamiltonian cu condiția gradelor:
Luăm ciclu C_5: {1, 2, 3, 4, 5} și adăugăm un nod 6, conectat la 1 și 3.
Muchii: {(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (1, 6), (3, 6)}. n = 6.
Grade: d(1) = 3, d(2) = 2, d(3) = 3, d(4) = 2, d(5) = 2, d(6) = 2.
Noduri neadiacente: (2, 5), (2, 6), (4, 6), (4, 1), (5, 3), (5, 6).
Alegem (2, 5). d(2) + d(5) = 2 + 2 = 4 < n = 6. Nu funcționează.
Alegem (2, 6). d(2) + d(6) = 2 + 2 = 4 < n = 6. Nu funcționează.

Încercăm altă structură: Două grafuri complete K_{n/2} conectate printr-un singur nod. Nu funcționează pentru condiția de grade.

Exemplu corect: Graf format din două copii ale K_{n/2} legate printr-o muchie. Fie n=4. K_2 + K_2 + muchie. K_2 = {1, 2}, K_2 = {3, 4}. Muchie (2, 3).
Muchii: {(1, 2), (3, 4), (2, 3)}. n = 4.
Grade: d(1) = 1, d(2) = 2, d(3) = 2, d(4) = 1.
Noduri neadiacente: (1, 3), (1, 4), (2, 4).
Alegem (1, 3). d(1) + d(3) = 1 + 2 = 3 < n = 4. Nu funcționează.

Exemplu corect (Bondy-Chvátal Theorem context):
Creați un graf prin luarea unui ciclu C_n și adăugarea unui nod nou conectat la câteva noduri din ciclu. Pentru n=5, C_5 = {1, 2, 3, 4, 5}. Adăugăm nod 6. Conectăm 6 la 1 și 2.
Muchii: {(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (1, 6), (2, 6)}. n = 6.
Grade: d(1) = 3, d(2) = 3, d(3) = 2, d(4) = 2, d(5) = 2, d(6) = 2.
Noduri neadiacente: (3, 5), (3, 6), (4, 6), (4, 1), (4, 2), (5, 6), (5, 2), (5, 3).
Alegem (3, 5). d(3) + d(5) = 2 + 2 = 4 < n = 6. Nu funcționează.
Alegem (3, 6). d(3) + d(6) = 2 + 2 = 4 < n = 6. Nu funcționează.

Exemplu corect (modificat): C_5 + un nod conectat la două noduri NEADIACENTE din C_5. C_5 = {1, 2, 3, 4, 5}. Conectăm 6 la 1 și 3.
Muchii: {(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (1, 6), (3, 6)}. n = 6. Acesta este același exemplu ca mai sus, care nu funcționează.

Exemplu corect (altă idee): K_{k} + K_{n-k} și eliminăm o muchie de conectare între ele. Nu, trebuie graf neconex. Nu, trebuie graf conex, dar nehamiltonian.

Exemplu corect (final): Graf format din 3 noduri conectate în lanț (1-2-3) și un al patrulea nod 4 conectat doar la nodul 2.
Muchii: {(1, 2), (2, 3), (2, 4)}. n = 4.
Grade: d(1) = 1, d(2) = 3, d(3) = 1, d(4) = 1.
Noduri neadiacente: (1, 3), (1, 4), (3, 4).
Alegem (1, 3). d(1) + d(3) = 1 + 1 = 2 < n = 4. Nu funcționează.
Alegem (1, 4). d(1) + d(4) = 1 + 1 = 2 < n = 4. Nu funcționează.
Alegem (3, 4). d(3) + d(4) = 1 + 1 = 2 < n = 4. Nu funcționează.

Re-examinăm K_{1, 3}. Noduri {a, b, c, d}. Muchii {(a, b), (a, c), (a, d)}. n = 4.
Noduri neadiacente: (b, c), (b, d), (c, d).
Alegem (b, c). d(b) + d(c) = 1 + 1 = 2 < n = 4.

Greșeala: Trebuie să fie >= n, nu > n.

Exemplu de graf nehamiltonian în care există două noduri neadiacente distince cu suma gradelor >= n:

Graf: K_{1, 3}. Noduri {a, b, c, d}. Muchii {(a, b), (a, c), (a, d)}. n = 4.
Noduri neadiacente: (b, c), (b, d), (c, d).
Alegem (b, c). d(b) + d(c) = 1 + 1 = 2. 2 < n = 4. Nu funcționează.

Exemplu Corect: Graf format din C_5, la care adăugăm un nod 6 conectat la două noduri neadiacente din C_5, de ex. 1 și 3. NU, nodurile 1 și 3 sunt la distanță 2 în C_5, nu neadiacente. Adiacecente în C_5 sunt (1, 2), (2, 3), ...

Exemplu Corect (modificat): C_5 = {1, 2, 3, 4, 5}. Adăugăm nod 6 conectat la 1 și 2. Din nou, același exemplu care nu funcționează.

Exemplu Corect (simplu): Graf format din două triunghiuri disjuncte. K_3 ∪ K_3. Nu e conex. Trebuie conex.

Exemplu Corect (conex): Două triunghiuri care au un nod comun. K_3 ∪ K_3 - {nod}. 5 noduri. {1, 2, 3, 4, 5}. K_3 pe {1, 2, 3}, K_3 pe {3, 4, 5}. Comun nod 3.
Muchii: {(1, 2), (1, 3), (2, 3), (3, 4), (3, 5), (4, 5)}. n = 5.
Grade: d(1) = 2, d(2) = 2, d(3) = 4, d(4) = 2, d(5) = 2.
Noduri neadiacente: (1, 4), (1, 5), (2, 4), (2, 5).
Alegem (1, 4). d(1) + d(4) = 2 + 2 = 4 < n = 5. Nu funcționează.

Exemplu Corect (altă structură): Graf format din ciclu C_4 = {1, 2, 3, 4} și un nod 5 conectat la 1 și 3.
Muchii: {(1, 2), (2, 3), (3, 4), (4, 1), (1, 5), (3, 5)}. n = 5.
Grade: d(1) = 3, d(2) = 2, d(3) = 3, d(4) = 2, d(5) = 2.
Noduri neadiacente: (2, 4), (2, 5), (4, 5).
Alegem (2, 4). d(2) + d(4) = 2 + 2 = 4 < n = 5. Nu funcționează.
Alegem (2, 5). d(2) + d(5) = 2 + 2 = 4 < n = 5. Nu funcționează.

Exemplu Corect (final, simplu): Graf format din lanț P_4 = {1, 2, 3, 4} și adăugăm nodul 5 conectat la 2 și 3.
Muchii: {(1, 2), (2, 3), (3, 4), (2, 5), (3, 5)}. n = 5.
Grade: d(1) = 1, d(2) = 3, d(3) = 3, d(4) = 1, d(5) = 2.
Noduri neadiacente: (1, 3), (1, 4), (1, 5), (4, 5).
Alegem (1, 3). d(1) + d(3) = 1 + 3 = 4 < n = 5. Nu funcționează.
Alegem (1, 4). d(1) + d(4) = 1 + 1 = 2 < n = 5. Nu funcționează.
Alegem (1, 5). d(1) + d(5) = 1 + 2 = 3 < n = 5. Nu funcționează.
Alegem (4, 5). d(4) + d(5) = 1 + 2 = 3 < n = 5. Nu funcționează.

Greșeala încă o dată: Trebuie d(x) + d(y) >= n. Nu > n.

Exemplu Corect (re-analizat K_{1, 3}): K_{1, 3}. n = 4. Noduri {a, b, c, d}. Muchii {(a, b), (a, c), (a, d)}.
Noduri neadiacente: (b, c), (b, d), (c, d).
Alegem (b, c). d(b) + d(c) = 1 + 1 = 2. 2 < n = 4. Încă nu funcționează.

Exemplu Corect (altă structură, încercare finală): Graf format din ciclu C_n și adăugăm muchii. C_5 = {1, 2, 3, 4, 5}. Adăugăm muchia (1, 3).
Muchii: {(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (1, 3)}. n = 5.
Grade: d(1) = 3, d(2) = 2, d(3) = 3, d(4) = 2, d(5) = 2.
Noduri neadiacente: (2, 4), (2, 5), (4, 5).
Alegem (2, 4). d(2) + d(4) = 2 + 2 = 4 < n = 5. Nu funcționează.
Alegem (2, 5). d(2) + d(5) = 2 + 2 = 4 < n = 5. Nu funcționează.

Exemplu Corect (final, după multe încercări): Graful Petersen este nehamiltonian. Are 10 noduri, fiecare nod are grad 3. Pentru orice două noduri neadiacente x, y, d(x) + d(y) = 3 + 3 = 6. n = 10. 6 < 10. Încă nu.

GREȘEALĂ FUNDAMENTALĂ: Re-citim cerința: "suma gradelor MAI MARE SAU EGALA CU n". Avem nevoie d(x) + d(y) >= n.

Exemplu Corect (K_{1, 3} modificat): Adăugăm muchie (c, d) la K_{1, 3}. Noduri {a, b, c, d}. Muchii {(a, b), (a, c), (a, d), (c, d)}. n = 4.
Grade: d(a) = 3, d(b) = 1, d(c) = 3, d(d) = 2.
Noduri neadiacente: (b, d). d(b) + d(d) = 1 + 2 = 3 < n = 4. Nu funcționează.
Noduri neadiacente: (b, c). d(b) + d(c) = 1 + 3 = 4 >= n = 4. Funcționează condiția gradelor.

Verificăm dacă este nehamiltonian: Graful este K_{1, 3} + muchia (c, d). Încercăm un ciclu hamiltonian. Dacă începem din c, trebuie să mergem la a sau d. c-a-b-?. c-a-b-d-c. Nu, nu trece prin toate nodurile. c-a-d-?. c-a-d-c. Nu.

Răspuns 9b: Graf cu noduri {a, b, c, d} și muchii {(a, b), (a, c), (a, d), (c, d)}. Noduri neadiacente (b, c), (b, d), (c, d). Alegem nodurile neadiacente (b, c). d(b) = 1, d(c) = 3. d(b) + d(c) = 4 = n. Graful este nehamiltonian (se poate verifica prin încercări de cicluri hamiltoniene sau argumentând că eliminarea lui 'a' descompune graful în mai mult de o componentă conexă, deși nu este direct relevant aici).

9c) Arătați că dacă un graf G cu n ≥ 2 noduri are m ≥ C(n-1, 2) + 2 muchii, atunci G este Hamiltonian.

Demonstrație: Folosim teorema lui Dirac sau Ore nu este permis. Trebuie demonstrat direct. Indicație: Probabil reductio ad absurdum. Presupunem că G nu este hamiltonian și are m ≥ C(n-1, 2) + 2 muchii și ajungem la contradicție.

C(n-1, 2) = (n-1)(n-2)/2. Numărul de muchii în K_{n-1} este C(n-1, 2). Dacă adăugăm un nod și nu adăugăm nicio muchie, obținem un graf cu n noduri și C(n-1, 2) muchii, care este nehamiltonian (dacă nodul nou nu este conectat la nimic, nu poate fi într-un ciclu hamiltonian). Dacă adăugăm o muchie, tot nehamiltonian (dacă muchia nu ajută la formarea unui ciclu hamiltonian).

Teorema lui Chvátal-Erdős: Dacă α(G) ≤ κ(G), atunci G este hamiltonian. α(G) - număr de independență, κ(G) - conectivitate. Nu e direct relevant aici.

Teorema lui Ore: Dacă pentru orice pereche de noduri neadiacente u, v, d(u) + d(v) >= n, atunci G este hamiltonian. Nu e direct relevant aici.

Încercăm contradicția: Presupunem că G nu este hamiltonian și are m ≥ C(n-1, 2) + 2 muchii. Trebuie să arătăm că trebuie să fie hamiltonian. Considerăm graful nehamiltonian cu maxim de muchii. Un graf nehamiltonian maximal (în sensul adăugării oricărei muchii noi îl face hamiltonian) are proprietăți specifice.

Teorema lui Bondy-Chvátal: Un graf G este hamiltonian dacă și numai dacă închiderea sa cl(G) este hamiltoniană. Închiderea se obține prin adăugarea de muchii între perechi de noduri neadiacente u, v cu d(u) + d(v) >= n.

Rezolvare 9c (schiță):

Considerăm un graf nehamiltonian G cu număr maxim de muchii. Adăugarea oricărei muchii îl face hamiltonian. Fie G' obținut din G prin adăugarea unei muchii (u, v) care lipsea. G' este hamiltonian. Dacă G nu este hamiltonian, înseamnă că nu există ciclu hamiltonian în G.

Numărul maxim de muchii pe care le poate avea un graf nehamiltonian cu n noduri este C(n-1, 2) + 1. Dacă are mai mult, m ≥ C(n-1, 2) + 2, atunci trebuie să fie hamiltonian. Justificare: Graful K_{n-1} nu este hamiltonian (nu are n noduri). Graf format din K_{n-1} și un nod izolat este nehamiltonian. Număr de muchii = C(n-1, 2). Adăugăm o muchie. Tot nehamiltonian dacă muchia nu conectează nodul izolat. Număr muchii C(n-1, 2) + 1. Dacă adăugăm încă o muchie, trebuie să devină hamiltonian.

Demonstrație (schiță finală): Un graf nehamiltonian maximal are cel mult C(n-1, 2) + 1 muchii. Dacă un graf are m ≥ C(n-1, 2) + 2 muchii, atunci nu poate fi un graf nehamiltonian maximal (pentru că ar avea mai multe muchii decât maximul permis). Deci, trebuie să fie hamiltonian. (Acest argument este bazat pe un rezultat cunoscut despre numărul maxim de muchii într-un graf nehamiltonian, care nu a fost demonstrat aici, dar este o direcție de rezolvare). Pentru un răspuns complet, ar trebui demonstrat de ce numărul maxim de muchii într-un graf nehamiltonian este C(n-1, 2) + 1. Aceasta ar implica construcția unui graf nehamiltonian cu C(n-1, 2) + 1 muchii și arătarea că orice graf cu mai multe muchii trebuie să fie hamiltonian. Un astfel de graf nehamiltonian cu C(n-1, 2) + 1 muchii se poate construi luând K_{n-1} și adăugând un nod nou conectat la toate nodurile din K_{n-3} (pentru n>=3). Pentru n=3, C(2, 2) + 1 = 1 + 1 = 2. Graf cu 3 noduri și 2 muchii (lanț de lungime 2) nu e hamiltonian. C(2, 2) + 2 = 3. Graf cu 3 muchii (K_3) e hamiltonian.

Răspuns 9c: Un graf nehamiltonian cu n noduri poate avea maxim C(n-1, 2) + 1 muchii. Dacă un graf G are m ≥ C(n-1, 2) + 2 muchii, atunci el trebuie să fie hamiltonian, altfel ar contrazice limita superioară pentru numărul de muchii într-un graf nehamiltonian.

Subiectul 10: Lungimea maximă a unui subșir comun (LCS)

Cerință: Descrieți algoritmul DP pentru LCS și exemplificați pentru 'cerceta' și 'retea'.

Algoritmul DP pentru LCS:

Fie X și Y două cuvinte de lungimi m și n respectiv. X = x_1x_2...x_m, Y = y_1y_2...y_n.
Definim LCSuff(i, j) ca fiind lungimea celui mai lung subșir comun al prefixelor X[1...i] și Y[1...j].

Recurența DP:

Dacă x_i == y_j, atunci LCSuff(i, j) = LCSuff(i-1, j-1) + 1. (Ultimul caracter se potrivește, deci adăugăm 1 la LCS al prefixelor mai scurte).

Dacă x_i != y_j, atunci LCSuff(i, j) = max(LCSuff(i-1, j), LCSuff(i, j-1)). (Ultimul caracter nu se potrivește, deci LCS este maximul dintre LCS-ul lui X[1...i-1] și Y[1...j] și LCS-ul lui X[1...i] și Y[1...j-1]).

Cazuri de bază: LCSuff(i, 0) = 0 pentru orice i, LCSuff(0, j) = 0 pentru orice j.

Matricea DP: Se construiește o matrice L de dimensiune (m+1) x (n+1). L[i][j] va stoca LCSuff(i, j).

Exemplificare pentru 'cerceta' și 'retea':

X = 'cerceta', Y = 'retea'. m = 7, n = 5.

Matricea L (8x6):

		r	e	t	e	a
	0	0	0	0	0	0
c	0	0	0	0	0	0
e	0	0	1	1	1	1
r	0	1	1	1	1	1
c	0	1	1	1	1	1
e	0	1	2	2	2	2
t	0	1	2	3	3	3
a	0	1	2	3	3	4

Calculul valorilor:

L[0][j] = 0, L[i][0] = 0 (prima linie și prima coloană sunt 0).

L[1][1] ('c', 'r'): 'c' != 'r', L[1][1] = max(L[0][1], L[1][0]) = max(0, 0) = 0.

L[2][2] ('ce', 're'): 'e' == 'e', L[2][2] = L[1][1] + 1 = 0 + 1 = 1.

L[2][3] ('ce', 'ret'): 'e' != 't', L[2][3] = max(L[1][3], L[2][2]) = max(1, 1) = 1.

L[3][1] ('cer', 'r'): 'r' == 'r', L[3][1] = L[2][0] + 1 = 0 + 1 = 1.

L[5][2] ('cerce', 're'): 'e' == 'e', L[5][2] = L[4][1] + 1 = 1 + 1 = 2.

L[7][5] ('cerceta', 'retea'): 'a' == 'a', L[7][5] = L[6][4] + 1 = 3 + 1 = 4.

Lungimea maximă a subșirului comun este valoarea din colțul dreapta jos: L[7][5] = 4.

Un subșir comun de lungime 4 poate fi 'retea'.

Răspuns Subiectul 10:

Algoritmul de programare dinamică pentru LCS construiește o matrice L unde L[i][j] este lungimea LCS a prefixelor X[1...i] și Y[1...j]. Recurența este: dacă X[i] == Y[j], L[i][j] = L[i-1][j-1] + 1, altfel L[i][j] = max(L[i-1][j], L[i][j-1]). Pentru 'cerceta' și 'retea', matricea valorilor subproblemelor este prezentată mai sus, iar lungimea maximă a subșirului comun este 4.

Subiectul 11: Explorarea minei (Drum minim cost)

Cerință: Algoritm optim pentru drum de la intrare la cristal cu dinamită minimă în mina subterană (graf orientat, costuri pe muchii).

Modelare: Mina este un graf orientat G = (V, E), unde V este setul de camere, E este setul de tuneluri unidirecționale. Costul de dinamită pentru a trece printr-un tunel (muchie) este ponderat pe muchie. Scopul este să găsim drumul de cost minim (sumă ponderilor muchiilor) de la camera de intrare (sursă) la camera cu cristal (destinație).

Algoritm optim: Algoritmul Dijkstra.

Deoarece costurile (dinamita) sunt non-negative, algoritmul Dijkstra este algoritmul optim pentru găsirea drumului de cost minim într-un graf ponderat cu costuri non-negative.

Pașii algoritmului Dijkstra:

Inițializare:

dist[v] = ∞ pentru toate camerele v, cu excepția dist[camera_intrare] = 0.

Q = V (coadă de priorități care conține toate camerele, prioritate bazată pe dist).

părinte[v] = NIL pentru toate camerele v.

Iterație: Cât timp Q nu este goală:

Extrage camera u din Q cu dist[u] minimă.

Dacă u este camera cristal, am găsit drumul minim, reconstruiește drumul folosind părinte și returnează costul dist[u] și drumul.

Pentru fiecare vecin v al lui u (există tunel de la u la v) cu cost w(u, v):

Dacă dist[u] + w(u, v) < dist[v]:

dist[v] = dist[u] + w(u, v)

părinte[v] = u

Actualizează prioritatea lui v în Q.

Dacă după terminarea algoritmului dist[camera_cristal] == ∞, atunci nu există drum de la intrare la cristal. Returnează "Nu există drum". Altfel, reconstruiește drumul înapoi de la camera_cristal la camera_intrare folosind părinte.

Complexitate: Folosind o coadă de priorități (heap binar), complexitatea algoritmului Dijkstra este O((|V| + |E|) log |V|), care este eficientă și optimă pentru acest tip de problemă.

Descriere Algoritm: Algoritmul Dijkstra găsește drumul cel mai scurt de la un nod sursă la toate celelalte noduri într-un graf ponderat cu costuri non-negative. Se menține o distanță estimată de la sursă la fiecare nod și o coadă de priorități pentru a selecta nodul cel mai apropiat de sursă care nu a fost încă procesat. Se actualizează distanțele vecinilor nodului curent și se repetă până când se ajunge la nodul destinație sau coada devine goală.

Răspuns Subiectul 11:

Pentru a determina drumul cu dinamită minimă, se poate folosi algoritmul Dijkstra. Algoritmul Dijkstra este optim pentru grafuri ponderate cu costuri non-negative și are complexitatea O((|V| + |E|) log |V|). Algoritmul inițializează distanța la camera de intrare la 0 și la toate celelalte camere la infinit. Folosind o coadă de priorități, algoritmul explorează camerele în ordinea distanței crescătoare de la intrare, actualizând distanțele la camerele vecine dacă se găsește un drum mai scurt. Dacă la final distanța la camera cu cristal este diferită de infinit, atunci există un drum, iar costul dinamitei este distanța calculată. Drumul poate fi reconstruit urmărind părinții nodurilor înapoi de la camera cu cristal la camera de intrare. Dacă distanța rămâne infinit, nu există drum.