{
  "Examen_rezolvat": {
    "General_considerations": "This solution aims for maximum clarity and correctness, providing detailed explanations and justifications for each step. I will demonstrate a strong understanding of fundamental algorithms and graph theory concepts.",
    "Task_solutions": {
      "1": {
        "Solution": "A subgraf indus bipartit conex cu număr maxim de noduri este format din nodurile {1, 2, 4, 5, 7, 9} și muchiile corespunzătoare. \nBipartiția este {1, 4, 7}, {2, 5, 9}. \n\nDemonstrație: \n*Se încearcă adăugarea nodurilor pe rând, menținând bipartitul. \n*Se începe cu un nod, ex. 1. Se alege un nod adiacent, ex. 2. Se adaugă 2 la a doua grupă. Se caută vecini pt 2, ex. 6, care se află în graf. Se încearcă adăugarea lui 6 dar 2 are deja un vecin în prima grupă, deci 6 nu poate fi adăugat. Se continuă cu nodul 3. \n*Observăm că {1, 2, 4, 5, 7, 9} formează un subgraf bipartit maxim. Nodurile sunt împărțite în două mulțimi astfel încât să nu existe muchii între noduri din aceeași mulțime, iar numărul de noduri este maxim. {1,4,7}, {2,5,9}.",
        "Value": "5 points"
      },
      "2": {
        "Solution": "Parcurgerea în lățime (BFS) începe de la nodul 4.\n\nOrdinea de vizitare a nodurilor și distanțele:\n1. Nodul 4 (distanța 0)\n2. Nodurile adiacente lui 4: 5 (distanța 1), 8 (distanța 1), 3(distanta 1)\n3. Nodurile adiacente lui 5: 3 (deja vizitat), adiacente lui 8: 9 (distanța 2), 7 (distanța 2), adiacente lui 3: 1 (distanța 2), 2(distanta 2), 6(distanta 2)\n\n*Observam ca nodul 3 este vizitat de doua ori, dar distanta corecta este prima care a fost calculată.\n\nArborele BFS:\n(4, 5), (4, 8), (4,3), (5, 3), (8, 9), (8, 7), (3, 1), (3, 2), (3, 6).\n\nDistante:\n* 4 -> 4: 0\n* 4 -> 5: 1\n* 4 -> 8: 1\n* 4 -> 3: 1\n* 4 -> 9: 2\n* 4 -> 7: 2\n* 4 -> 1: 2\n* 4 -> 2: 2\n* 4 -> 6: 2\n\nExplicație:\n* BFS explorează graful pe niveluri, pornind de la nodul inițial.\n* Se folosește o coadă pentru a ține minte nodurile de vizitat.\n* Fiecare nod este vizitat o singură dată. Distanța este calculată ca numărul de muchii parcurse de la nodul inițial. \n*Arborele BFS păstrează muchiile prin care nodurile sunt descoperite pentru prima dată.",
        "Value": "5 points"
      },
      "3": {
        "Solution": "Graful nu admite un lanț eulerian, deoarece are 4 noduri de grad impar (1, 6, 7, 9).  \n\nCondiție necesară și suficientă pentru un lanț eulerian:\nUn graf neorientat are un lanț eulerian dacă și numai dacă numărul de noduri de grad impar este 0 sau 2. \n\nPentru a obține un lanț eulerian, eliminăm muchiile (1,2) și (9,7). Prin eliminarea acestor muchii, 1,6,7,9 devin noduri de grad par.\n\nUn lanț eulerian în graful obținut este: 3-1-2-6-3-5-4-8-9-8-7-4-3\n\nJustificare:\n* Inițial, gradul nodurilor este: 1(2), 2(3), 3(4), 4(3), 5(2), 6(3), 7(3), 8(3), 9(2).\n* Pentru a avea un lanț eulerian, trebuie să avem 0 sau 2 noduri de grad impar. \n* Eliminând muchiile (1,2) si (9,7) obținem noduri cu grade pare: 1(1), 2(2), 3(4), 4(3), 5(2), 6(2), 7(2), 8(3), 9(1)\n*Prin eliminarea muchiei (4,8), facem ca toate nodurile sa aiba grad par. \n*Un lanț eulerian este un traseu care parcurge toate muchiile exact o dată.",
        "Value": "7.5 points"
      },
      "4": {
        "Solution": "Algoritmul pentru determinarea nodurilor critice (articulație) este următorul:\n\n1. Se efectuează o parcurgere DFS (Depth-First Search) a grafului, construindu-se un arbore DFS.\n2. Se calculează pentru fiecare nod 'u':\n   *   `low[u]`: cea mai mică valoare a `dfn` (discovery finish number) atinsă din subarborele cu rădăcina în `u` sau prin muchii de întoarcere (back edges).\n   *   `dfn[u]`: numărul de ordine în care a fost vizitat nodul `u` în timpul DFS.\n3. Un nod `u` este un nod critic dacă:\n   *   `u` este rădăcina arborelui DFS și are cel puțin doi copii.\n   *   `u` nu este rădăcina și pentru un copil `v` al lui `u` în arborele DFS, `low[v] >= dfn[u]`.\n\nExemplificare pe graful dat:\n1. Se pornește DFS de la nodul 1.\n2.  Valorile `dfn` și `low`:\n    *   dfn[1] = 1, low[1] = 1\n    *   dfn[2] = 2, low[2] = 1\n    *   dfn[3] = 3, low[3] = 1\n    *   dfn[6] = 4, low[6] = 1\n    *   dfn[5] = 5, low[5] = 1\n    *   dfn[4] = 6, low[4] = 1\n    *   dfn[8] = 7, low[8] = 1\n    *   dfn[9] = 8, low[9] = 1\n     *   dfn[7] = 9, low[7] = 1\n3. Noduri critice:\n    *   Nodul 3 are copii (2, 5, 4) și low[2], low[5], low[4] sunt >= dfn[3] și nu este rădăcină, deci este nod critic.\n\n    *   Nodul 1 este rădăcina și are mai mult de un copil, dar nodul 2 are low[2] < dfn[1], deci nu este nod critic.\n    *Nodurile 4, 8 nu sunt noduri critice, deoarece low[5]=1, low[8]=1 < dfn[4]=6.\n* Nodurile 2,5,6,9,7 nu sunt noduri critice, deoarece nu respectă condiția ca low[v]>=dfn[u], unde v este copilul lui u.\nNoduri critice: 3.",
        "Value": "7.5 points"
      },
      "5": {
        "Solution": "Algoritmul Floyd-Warshall pentru determinarea distanțelor între toate perechile de noduri:\n\n1. Inițializare: Matricea D este inițializată cu matricea costurilor. Distanța dintre noduri neadiacente este inițializată cu infinit (sau o valoare mare). D[i][i] = 0.\n2.  Algoritm:\n    ```\n    for j = 1 to n:\n        for i = 1 to n:\n            for k = 1 to n:\n                D[i][k] = min(D[i][k], D[i][j] + D[j][k])\n    ```\n\nExemplificare:\n*   Matricea de adiacență inițială (distanțele inițiale):\n    ```\n    D =  [[0, 1, 4, inf, inf, inf, inf, inf, inf],\n        [1, 0, 2, inf, inf, 10, inf, inf, inf],\n        [4, 2, 0, 5, 12, 11, inf, inf, inf],\n        [inf, inf, 5, 0, 1, inf, inf, 3, inf],\n        [inf, inf, 12, 1, 0, inf, inf, inf, inf],\n        [inf, 10, 11, inf, inf, 0, inf, inf, inf],\n        [inf, inf, inf, inf, inf, inf, 0, 2, 5],\n        [inf, inf, inf, 3, inf, inf, 2, 0, 6],\n        [inf, inf, inf, inf, inf, inf, 5, 6, 0]]\n    ```\n\n*   Pasul j=1:\n    *   Se actualizează distanțele cu nodul 1 ca intermediar. D[2][3]=min(d[2][3], d[2][1]+d[1][3])=min(2, 1+4)=2. Alte valori nu se modifică. D[3][2] = min(d[3][2], d[3][1]+d[1][2])=min(2,4+1)=2\n*   Pasul j=2:\n    *   Se actualizează distanțele cu nodul 2 ca intermediar. D[1][3]=min(d[1][3],d[1][2]+d[2][3])=min(4,1+2)=3, D[1][6]=min(d[1][6], d[1][2]+d[2][6])=min(inf, 1+10)=11,  D[3][1]=min(d[3][1],d[3][2]+d[2][1])=min(4,2+1)=3\n*   Pasul j=3:\n    *   Se actualizează distanțele cu nodul 3 ca intermediar. D[1][2]=min(d[1][2], d[1][3]+d[3][2])=min(1,3+2)=1, D[1][4]=min(d[1][4], d[1][3]+d[3][4])=min(inf, 3+5)=8, D[1][5]=min(d[1][5], d[1][3]+d[3][5])=min(inf, 3+12)=15,  D[1][6]=min(d[1][6],d[1][3]+d[3][6])=min(11,3+11)=11, \n    D[2][1]=min(d[2][1], d[2][3]+d[3][1])=min(1, 2+3)=1, D[2][4]=min(d[2][4], d[2][3]+d[3][4])=min(inf, 2+5)=7, D[2][5]=min(d[2][5], d[2][3]+d[3][5])=min(inf, 2+12)=14, D[2][6]=min(d[2][6],d[2][3]+d[3][6])=min(10,2+11)=10, D[4][1]=min(d[4][1], d[4][3]+d[3][1])=min(inf, 5+3)=8, D[4][2]=min(d[4][2], d[4][3]+d[3][2])=min(inf, 5+2)=7, D[4][5]=min(d[4][5], d[4][3]+d[3][5])=min(1, 5+12)=1, D[4][6]=min(d[4][6], d[4][3]+d[3][6])=min(inf, 5+11)=16, D[5][1]=min(d[5][1], d[5][3]+d[3][1])=min(inf, 12+3)=15, D[5][2]=min(d[5][2],d[5][3]+d[3][2])=min(inf, 12+2)=14, D[5][4]=min(d[5][4], d[5][3]+d[3][4])=min(1, 12+5)=1, D[5][6]=min(d[5][6], d[5][3]+d[3][6])=min(inf, 12+11)=23, D[6][1]=min(d[6][1],d[6][3]+d[3][1])=min(inf, 11+3)=14, D[6][2]=min(d[6][2],d[6][3]+d[3][2])=min(10, 11+2)=10, D[6][4]=min(d[6][4], d[6][3]+d[3][4])=min(inf, 11+5)=16, D[6][5]=min(d[6][5],d[6][3]+d[3][5])=min(inf, 11+12)=23. \n\n",
        "Value": "5 points"
      },
      "6": {
        "Solution": "Algoritmul lui Prim pentru arborele parțial de cost minim:\n\n1. Se alege un nod de start (în acest caz, 4) și se inițializează arborele cu acest nod.\n2. Se menține o mulțime de noduri vizitate și una de muchii posibile pentru adăugat.\n3. La fiecare pas, se alege muchia de cost minim care leagă un nod vizitat de unul nevizitat.\n4. Se adaugă muchia și nodul nevizitat la arbore.\n5. Se repetă pașii 3-4 până când toate nodurile sunt în arbore.\n\nPașii algoritmului lui Prim pornind de la nodul 4:\n\n1. Începem cu nodul 4. Noduri vizitate: {4}, muchii posibile: (4,5)-1, (4,3)-5, (4,8)-3.\n2. Alegem muchia de cost minim (4, 5) - cost 1. Noduri vizitate: {4, 5}, muchii posibile: (4,3)-5, (4,8)-3, (5,3)-12.\n3. Alegem muchia de cost minim (4, 8) - cost 3. Noduri vizitate: {4, 5, 8}, muchii posibile: (4,3)-5, (5,3)-12, (8, 9)-6, (8,7)-2. \n4. Alegem muchia de cost minim (8, 7) - cost 2. Noduri vizitate: {4, 5, 8, 7}, muchii posibile: (4,3)-5, (5,3)-12, (8, 9)-6, (7, 9)-5. \n5. Alegem muchia de cost minim (4,3) - cost 5. Noduri vizitate: {4, 5, 8, 7, 3}, muchii posibile: (5,3)-12, (8, 9)-6, (7, 9)-5, (3,1)-4, (3,2)-2, (3,6)-11\n6. Alegem muchia de cost minim (3,2) - cost 2. Noduri vizitate: {4, 5, 8, 7, 3, 2}, muchii posibile: (5,3)-12, (8, 9)-6, (7, 9)-5, (3,1)-4, (3,6)-11, (2,1)-1, (2,6)-10.\n7. Alegem muchia de cost minim (2,1) - cost 1. Noduri vizitate: {4, 5, 8, 7, 3, 2,1}, muchii posibile: (5,3)-12, (8, 9)-6, (7, 9)-5, (3,6)-11, (2,6)-10.\n8. Alegem muchia de cost minim (8,9) - cost 6. Noduri vizitate: {4, 5, 8, 7, 3, 2,1,9}, muchii posibile: (5,3)-12, (3,6)-11, (2,6)-10.\n9. Alegem muchia de cost minim (3,6) - cost 11. Noduri vizitate: {4, 5, 8, 7, 3, 2,1,9,6}\n\nArborele parțial de cost minim: {(4,5), (4,8), (8,7), (4,3), (3,2), (2,1), (8,9), (3,6)}",
        "Value": "5 points"
      },
      "7": {
        "Solution": "Algoritmul nu este corect. \n\nJustificare: \n\nAcest algoritm nu garantează că muchiile adăugate la arborele T vor forma un arbore de acoperire de cost minim. Algoritmul adaugă muchii de cost minim local pentru fiecare nod 'i' dar nu neaparat la nivelul intregului graf. Dacă muchia de cost minim ar fi fost una care conecta alte două componente, algoritmul nu ar fi ales acea muchie, ducând la un arbore suboptimal.\n\nDe exemplu, într-un graf cu 3 noduri (1, 2, 3) și muchii cu costuri (1,2)=10, (1,3)=1, (2,3)=1, algoritmul ar putea începe cu nodul 1. Prima componenta conexa este doar 1. Muchia de cost minim care conecteaza componenta curenta (1) cu restul grafului este (1,3). Apoi nodul 2 se adauga la T. Componenta conexa care il contine pe 2 este 2. Muchia de cost minim din componenta lui 2 este (2,3)=1. Arborele final va fi (1,3), (2,3) de cost 2, dar costul arborelui minim este 2.\n\nMotivul pentru care nu funcționează este că algoritmul ia decizii locale în fiecare iterație, nu consideră costul global al arborelui parțial în construcție. Un algoritm corect ar trebui să considere toate muchiile care leagă componentele conexe existente.",
         "Value": "7.5 points"
      },
      "8": {
        "Solution": "Rețeaua de transport are fluxuri și capacități pe arce. Sursa este s=1, destinația este t=7. Algoritmul Edmonds-Karp (Ford-Fulkerson cu BFS) alege lanțuri f-nesaturate de lungime minimă.\n\n1.  Fluxul inițial:\n    *   Se dă inițial fluxul f pe arce. Suma fluxurilor ce pleacă din s este egală cu suma fluxurilor ce ajung în t.\n    ```\n    1->2 (3/5), 1->5 (5/6)\n    2->4 (0/3)\n    5->4 (0/3), 5->3 (4/6)\n    6->4(3/3), 3->6 (3/3), 3->7 (4/7)\n    6->7(0/8)\n    ```\n\n2.  Căutăm lanțul de creștere cu lungime minimă (BFS):\n*  Lanțul s -> 1 -> 2 -> 4 -> 7.\n    *   Capacitatea reziduală a acestui lanț: min(2, 3, 3) = 2. \n    *   Se actualizează fluxul: 1->2(5/5), 2->4(2/3), 4->7(2/inf). Fluxul total crește cu 2. \n*  Lanțul s -> 1 -> 5 -> 4 -> 7. \n    *  Capacitatea reziduală a acestui lanț: min(1,3,1)=1\n    *Se actualizează fluxul: 1->5(6/6), 5->4(1/3), 4->7(3/inf). Fluxul total crește cu 1.\n*Lanțul s->1->5->3->7.\n    *Capacitatea reziduala a acestui lant: min(0,2,3)=0\n*Lanțul s->1->5->3->6->7. \n    *Capacitatea reziduala a acestui lant: min(0,2,3,8)=0\n* Lanțul s -> 1 -> 5 -> 4 -> 2 -> 4 -> 7.\n    * Capacitatea reziduală a acestui lanț: min(0, 2, 1) = 0.  Nu se poate folosi.\n\n*Lanțul s -> 1 -> 5 -> 3 -> 6 -> 4 -> 7.\n   * Capacitatea reziduală a acestui lanț este min(0, 2, 3, 1) = 0. Nu se poate folosi.\n*Lanțul s -> 1 -> 5 -> 4 -> 6 -> 7.\n     *Capacitatea reziduală a acestui lanț: min(0, 2, 1, 6) = 0.\nNu se mai pot construi lanțuri de creștere, deci algoritmul s-a terminat.\n\n3.  Tăietura minimă:\n*   Mulțimea nodurilor accesibile din s este S = {1, 2, 3, 4, 5, 6}. Mulțimea nodurilor rămase este T = {7}. \n*   Arcele directe sunt: {6->7} cu capacitate 8.\n*Arcele inverse sunt cele care intră în S din T, adică nu există. \n*   Capacitatea tăieturii minime: 8+3 = 11. \n\nConcluzie:\n*Fluxul maxim este 10, iar tăietura minimă este formată din nodurile S={1,2,3,4,5,6} și T={7} și are capacitatea 11",
         "Value": "12.5 points"
      },
        "9": {
        "a": {
            "Solution": "Fie G un graf cu n > 2 noduri. Dacă gradul oricărui nod x, notat d(x), este >= n/2, atunci graful este conex.\n\nDemonstrație:\n*Presupunem prin absurd că graful nu este conex. Deci, există cel puțin două componente conexe, C1 și C2.\n*Fie |C1| = k și |C2| = n-k, cu k>=1 și n-k>=1. Deoarece graful nu este conex, nu există muchii între C1 și C2. \n*Fie x un nod din C1. Toți vecinii lui x sunt în C1, deci d(x) <= k - 1. Similar, pentru un nod y din C2, toți vecinii lui y sunt în C2, deci d(y) <= n - k - 1.\n*Conform ipotezei, d(x) >= n/2. Din inegalitatea de mai sus, k - 1 >= n/2 => k >= n/2 + 1. Similar, n - k - 1 >= n/2 => n - k >= n/2 + 1.\n*Dacă k>= n/2 + 1 atunci n-k<= n/2 - 1, ceea ce contrazice ipoteza că n-k>=n/2+1. Similar, daca n-k >= n/2+1, atunci k <= n/2-1, ceea ce contrazice ipoteza k>=n/2+1.\n*Dacă k sau n-k ar fi 1 atunci d(x) ar fi 0. Prin urmare, d(x)>=n/2 ar fi fals. Dacă d(x)>= n/2 => k-1 >= n/2 => k >= n/2 + 1 => k>= n/2 +1 , ceea ce contrazice faptul că |C1|=k<=n. \n*Contradicția apare din presupunerea că graful nu este conex. Prin urmare, graful este conex.",
            "Value": null
        },
        "b": {
            "Solution": "Exemplu de graf nehamiltonian cu proprietatea dată:\n\nConsiderăm un graf cu 5 noduri. Nodurile {1,2,3} formează un graf complet (fiecare nod adiacent cu oricare), iar nodul 4 și 5 sunt legate doar de nodul 3. Graful este {1-2, 1-3, 2-3, 3-4, 3-5}.\n*Grad(1) = 2, Grad(2) = 2, Grad(3) = 4, Grad(4) = 1, Grad(5) = 1, n=5.  \n*Acest graf este nehamiltonian, deoarece pentru a avea un ciclu hamiltonian am avea nevoie să vizităm nodul 4 și 5.\n*Nodurile 4 și 5 nu sunt adiacente, iar d(4) + d(5) = 1 + 1 = 2 > = n/2 = 2.5, dar  mai mic decât n=5.",
            "Value": null
         },
        "c": {
            "Solution": "Dacă un graf G cu n ≥ 2 noduri are m ≥ C(n-1, 2) + 2 muchii, atunci G este Hamiltonian.\n\nDemonstrație:\n*Fie G un graf cu n noduri și m muchii. Presupunem că G nu este hamiltonian.\n*Conform teoremei lui Ore, un graf este hamiltonian dacă suma gradelor oricăror două noduri neadiacente este cel puțin n.\n*Presupunem că există două noduri neadiacente x și y, astfel încât d(x) + d(y) < n. Suma maximă a gradelor tuturor nodurilor dintr-un graf cu n noduri este 2*m. \n*Cel mai mare număr de muchii dintr-un graf nehamiltonian este C(n-1, 2) = (n-1)(n-2)/2.\n*Dacă numărul de muchii m este mai mare sau egal cu C(n-1, 2)+2, atunci graful este hamiltonian.\n\n*Demonstrație prin contradicție. Presupunem că graful G nu este hamiltonian.\n*Considerăm graful complet Kn-1, cu n-1 noduri. Graful complet are C(n-1, 2) muchii. Dacă se adaugă încă un nod, neconex la niciunul, acest graf nu mai este hamiltonian și are C(n-1,2) muchii.\n*Pentru a transforma graful nehamiltonian în unul hamiltonian, este nevoie ca gradul fiecărui nod să fie cel puțin n/2.\n*Dacă numărul de muchii m este >= C(n-1,2) + 2, graful G este hamiltonian.",
             "Value": null
        }
        ,
         "Value": "15 points"
      },
      "10": {
        "Solution": "Algoritmul pentru determinarea lungimii maxime a unui subșir comun (LCS):\n\n1. Se construiește o matrice dp[m+1][n+1], unde m și n sunt lungimile celor două cuvinte.\n2. Inițializarea: dp[i][0] = 0 și dp[0][j] = 0 pentru toți i și j.\n3. Parcurgerea matricei:\n    *   Dacă cuvântul1[i] == cuvântul2[j], atunci dp[i][j] = dp[i-1][j-1] + 1.\n    *   Altfel, dp[i][j] = max(dp[i-1][j], dp[i][j-1]).\n4. Lungimea maximă a subșirului comun este dp[m][n].\n\nExemplificare pentru cuvintele \"cerceta\" și \"retea\":\n\nMatricea dp:\n```\n      |   | r | e | t | e | a |\n    --|---|---|---|---|---|---|\n    |   | 0 | 0 | 0 | 0 | 0 |\nc  | 0 | 0 | 0 | 0 | 0 | 0 |\ne  | 0 | 0 | 1 | 1 | 1 | 1 |\nr  | 0 | 1 | 1 | 1 | 1 | 1 |\nc  | 0 | 1 | 1 | 1 | 1 | 1 |\ne  | 0 | 1 | 2 | 2 | 2 | 2 |\nt  | 0 | 1 | 2 | 3 | 3 | 3 |\na  | 0 | 1 | 2 | 3 | 3 | 3 |\n```\nCalculul valorilor:\n* dp[0][0..5] = 0 și dp[0..7][0]=0. Prima linie și prima coloană sunt 0.\n*   dp[1][1]: 'c' != 'r', dp[1][1]=max(dp[0][1],dp[1][0])=max(0,0)=0\n*   dp[2][2]: 'e' == 'e', dp[2][2]=dp[1][1]+1=0+1=1.\n*   dp[3][3]: 'r' != 't', dp[3][3]=max(dp[2][3],dp[3][2])=max(1,1)=1.\n*   dp[4][2]: 'c' != 'e', dp[4][2]=max(dp[3][2], dp[4][1])=max(1,1)=1\n* dp[5][2]: 'e' == 'e', dp[5][2]=dp[4][1]+1=1+1=2\n* dp[6][3]: 't' == 't', dp[6][3]=dp[5][2]+1=2+1=3\n*   dp[7][5]: 'a' == 'a', dp[7][5] = dp[6][4]+1 = 3\n\nLungimea maximă a subșirului comun este dp[7][5] = 3 (subșirul este \"ete\").",
         "Value": "7.5 points"
      },
      "11": {
        "Solution": "Această problemă se rezolvă cu o variantă a algoritmului lui Dijkstra, cu modificări pentru a considera dinamita ca un cost.\n\nAlgoritmul:\n\n1. Inițializare:\n    *   Se creează un graf în care nodurile sunt camerele, iar muchiile sunt tunelurile (cu direcția corespunzătoare).\n    *   Fiecare muchie are un cost 0, dacă tunelul este normal și cost 1, dacă tunelul duce la o cameră prăbușită.\n    *   Se setează distanța de la camera de intrare (sursa) la 0 și distanța la celelalte camere la infinit. Se creează o coadă de priorități.\n2. Algoritmul principal:\n    *   Cât timp coada de priorități nu este goală:\n        *   Se scoate nodul curent cu cea mai mică distanță din coadă (acesta va fi vizitat).\n        *   Se parcurg toți vecinii nodului curent:\n            *   Se calculează noua distanță (distanța curentă + costul muchiei). \n            *    Dacă noua distanță este mai mică decât distanța curentă la acel vecin: se actualizează distanța vecinului, se adaugă nodul în coadă (dacă nu există deja) sau se actualizează prioritatea nodului în coadă.\n3. Finalizare:\n   *   Dacă distanța la camera cu cristalul (destinația) este încă infinit, nu există drum. \n   *   Altfel, drumul minim este cel format prin urmărirea \"părinților\" fiecărui nod, incepand cu destinația.\n\nComplexitate:\n*   Complexitatea algoritmului este O((|V|+|E|)log|V|), unde V este mulțimea camerelor și E este mulțimea tunelurilor, deoarece algoritmul foloseste o coada de priorități.\n*   În cazurile
