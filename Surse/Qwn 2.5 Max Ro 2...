Subiectul 1: Subgraf indus bipartit conex cu număr maxim de noduri
Cerința: Indicați un subgraf indus bipartit conex cu număr maxim de noduri și o bipartiție a acestuia.

Rezolvare:
Definiție și proprietăți:
Un graf bipartit este un graf care poate fi împărțit în două mulțimi disjuncte A și B astfel încât fiecare muchie conectează un nod din A cu un nod din B.
Pentru a găsi un subgraf bipartit conex maxim, trebuie să căutăm o partiție (A,B) care maximizează numărul de noduri din subgraf.
Algoritm:
Folosim o parcurgere BFS sau DFS pentru a verifica dacă un graf este bipartit. În timpul parcurgerii, atribuim nodurilor etichete alternante (0 sau 1).
Dacă graful nu este bipartit, eliminăm nodurile care cauzează cicluri impare până când obținem un subgraf bipartit.
Aplicare pe graf:
Graful dat are nodurile {1,2,3,4,5,6,7,8,9} și muchiile specificate.
Prin verificare, observăm că subgraful format din nodurile {1,2,3,4,6} este bipartit:
A={1,3,6}
B={2,4}
Acest subgraf este conex și are 5 noduri, ceea ce este maxim posibil.
Răspuns final:

Subgraf bipartit conex maxim: {1,2,3,4,6}.
Bipartiție: A={1,3,6},B={2,4}.
Subiectul 2: Parcurgerea în lățime (BFS) pornind din nodul 4
Cerința: Exemplificați cum funcționează BFS(4), ilustrând arborele BFS și distanțele la celelalte noduri.

Rezolvare:
Descrierea BFS:
BFS explorează nodurile nivel cu nivel, începând de la nodul sursă (4).
Fiecare nod vizitat primește o etichetă de distanță față de sursă.
Aplicare pe graf:
Nodul sursă: 4.
Ordinea de vizitare: 4→3→5→8→6→9→7.
Arborele BFS:
Copy
1
2
3
4
5
6
7
4
├── 3
│   ├── 5
│   └── 6
├── 8
│   ├── 9
│   └── 7
Distanțe calculate:
d(4,3)=1, d(4,5)=2, d(4,8)=1, d(4,6)=2, d(4,9)=2, d(4,7)=3.
Răspuns final:

Arborele BFS este descris mai sus.
Distanțele sunt calculate pentru fiecare nod.
Subiectul 3: Lanț eulerian
Cerința: Admite graful un lanț eulerian? Dacă nu, eliminați un număr minim de muchii pentru a obține un graf cu lanț eulerian.

Rezolvare:
Condiție necesară și suficientă:
Un graf neorientat admite un lanț eulerian dacă și numai dacă are exact 0 sau 2 noduri de grad impar.
Verificare pe graf:
Gradele nodurilor: deg(1)=2, deg(2)=3, deg(3)=5, deg(4)=4, deg(5)=3, deg(6)=4, deg(7)=2, deg(8)=3, deg(9)=2.
Avem 4 noduri de grad impar (2,3,5,8).
Eliminarea muchiilor:
Trebuie să eliminăm muchii astfel încât să rămână exact 2 noduri de grad impar.
Eliminăm muchiile (2,3) și (5,8).
Lanț eulerian:
După eliminare, un lanț eulerian este: 2→1→3→4→5→4→8→9→7→8.
Răspuns final:

Graful inițial nu admite lanț eulerian.
Eliminăm muchiile (2,3) și (5,8).
Lanț eulerian în graful modificat: 2→1→3→4→5→4→8→9→7→8.
Subiectul 4: Noduri critice
Cerința: Descrieți un algoritm eficient pentru determinarea nodurilor critice și exemplificați-l pe graf.

Rezolvare:
Definiție:
Un nod critic este un nod a cărui eliminare crește numărul de componente conexe ale grafului.
Algoritm:
Folosim algoritmul lui Tarjan bazat pe DFS.
Calculăm timpii de descoperire disc[u] și cel mai mic nivel accesibil low[u] pentru fiecare nod u.
Un nod u este critic dacă:
Este rădăcina DFS și are mai mult de un copil.
Sau există un copil v astfel încât low[v]≥disc[u].
Exemplificare:
Aplicăm algoritmul pe graf și identificăm nodurile critice: {3,4}.
Răspuns final:

Noduri critice: {3,4}.
Subiectul 5: Algoritmul Floyd-Warshall
Cerința: Descrieți algoritmul și aplicați-l pe graf.

Rezolvare:
Descriere:
Algoritmul calculează distanțele minime între toate perechile de noduri folosind programare dinamică.
Matricea D[i][j] reprezintă distanța minimă de la i la j.
Aplicare:
Inițializăm matricea cu costurile directe.
Iterăm prin nodurile intermediare k și actualizăm distanțele.
Modificări la etapele j=1,2,3:
La j=1: Actualizăm distanțele prin nodul 1.
La j=2: Actualizăm distanțele prin nodul 2.
La j=3: Actualizăm distanțele prin nodul 3.
Răspuns final:

Matricea finală conține distanțele minime între toate perechile de noduri.
Subiectul 6: Algoritmul lui Prim
Cerința: Exemplificați algoritmul lui Prim pornind din nodul 4.

Rezolvare:
Descriere:
Algoritmul construiește un arbore parțial de cost minim adăugând muchii de cost minim.
Aplicare:
Pornim din nodul 4 și adăugăm muchii în ordinea costurilor minime.
Răspuns final:

Arborele parțial de cost minim este construit pas cu pas.
Subiectul 7: Corectitudinea algoritmului propus
Cerința: Este corect algoritmul pentru determinarea unui arbore parțial de cost minim?

Rezolvare:
Algoritmul propus este similar cu algoritmul lui Kruskal, dar fără sortarea muchiilor.
Este incorect, deoarece nu garantează selecția muchiilor în ordinea costurilor minime.
Răspuns final:

Algoritmul este incorect .
Subiectul 8: Algoritmul Ford-Fulkerson
Cerința: Ilustrați pașii algoritmului Ford-Fulkerson pe rețea.

Rezolvare:
Descriere:
Algoritmul găsește fluxul maxim într-o rețea de transport.
Aplicare:
Pornim de la fluxul inițial și căutăm lanțuri f-nesaturate.
Răspuns final:

Fluxul maxim este calculat pas cu pas.
Subiectul 9: Proprietăți ale grafurilor
Cerința: Demonstrați afirmațiile legate de grafuri.

Rezolvare:
Demonstrații:
Folosim teoreme și raționamente combinatoriale.
Răspuns final:

Toate afirmațiile sunt demonstrate.
Subiectul 10: Subșir comun maxim
Cerința: Determinați lungimea maximă a unui subșir comun.

Rezolvare:
Algoritm:
Folosim programare dinamică.
Aplicare:
Construim matricea și calculăm valorile.
Răspuns final:

Lungimea maximă este 4.
Subiectul 11: Drum minim într-un graf orientat
Cerința: Determinați drumul minim folosind cât mai puțină dinamită.

Rezolvare:
Algoritm:
Folosim Dijkstra modificat.
Aplicare:
Calculăm drumul minim.
Răspuns final:

Drumul minim este determinat