Subgraf indus bipartit conex maximal (5p)
Cel mai mare subgraf indus bipartit conex conține nodurile {4,5,8,7,9}.
Bipartiția este:


Mulțimea A: {4,8}
Mulțimea B: {5,7,9}
Este maximal deoarece adăugarea oricărui alt nod ar crea un ciclu impar.


BF(4) și calculul distanțelor (5p)
Parcurgerea în lățime pornind din nodul 4:


Nivel 0: 4
Nivel 1: 3,5,8 (vecini direcți)
Nivel 2: 1,2,6,7,9 (vecinii vecinilor)
Nivel 3: niciun nod nou

Distanțele de la nodul 4 la celelalte noduri:

d(4,4) = 0
d(4,3) = d(4,5) = d(4,8) = 1
d(4,1) = d(4,2) = d(4,6) = d(4,7) = d(4,9) = 2

Arborele BFS arată astfel:
Copy       4
    /  |  \
   3   5   8
 /  \     / \
1    2   7   9
     |
     6

Lanț eulerian (7.5p)
Pentru ca un graf neorientat să aibă lanț eulerian, trebuie să îndeplinească una din condițiile:


Toate nodurile au grad par, sau
Exact două noduri au grad impar

În graful nostru, nodurile cu grad impar sunt: 1,2,4,6
Având 4 noduri de grad impar, trebuie să eliminăm minimum o muchie pentru a obține un lanț eulerian.
Strategia: Eliminăm muchia (2,6) care are cost maxim dintre muchiile care conectează noduri de grad impar.
După eliminare, obținem un lanț eulerian: 1-2-3-4-5-3-6-2-1

Noduri critice (7.5p)
Un nod este critic (punct de articulație) dacă prin eliminarea sa graful se deconectează.
Folosind algoritmul DFS implementat, nodurile critice sunt: {3,8}
Explicație:


Nodul 3 este critic pentru că separă submulțimea {1,2,6} de {4,5}
Nodul 8 este critic pentru că separă submulțimea {7,9} de restul grafului


Floyd-Warshall (5p)
Algoritmul Floyd-Warshall inițializează matricea D cu:


D[i][i] = 0 pentru orice i
D[i][j] = costul muchiei (i,j) dacă există
D[i][j] = ∞ dacă nu există muchie

La pasul j=1:
Copy    1  2  3  4  5  6  7  8  9
1   0  1  4  ∞  ∞  ∞  ∞  ∞  ∞
2   1  0  2  ∞  ∞ 10  ∞  ∞  ∞
3   4  2  0  5 12 11  ∞  ∞  ∞
4   ∞  ∞  5  0  1  ∞  ∞  3  ∞
5   ∞  ∞ 12  1  0  ∞  ∞  ∞  ∞
6   ∞ 10 11  ∞  ∞  0  ∞  ∞  ∞
7   ∞  ∞  ∞  ∞  ∞  ∞  0  2  5
8   ∞  ∞  ∞  3  ∞  ∞  2  0  6
9   ∞  ∞  ∞  ∞  ∞  ∞  5  6  0

Algoritmul lui Prim (5p)
Pornind din nodul 4:
Selectăm muchia (4,5) cu cost 1
Selectăm muchia (4,8) cu cost 3
Selectăm muchia (4,3) cu cost 5
Selectăm muchia (8,7) cu cost 2
Selectăm muchia (8,9) cu cost 6
Selectăm muchia (3,2) cu cost 2
Selectăm muchia (3,1) cu cost 4
Selectăm muchia (3,6) cu cost 11

Arborele parțial de cost minim are cost total = 34.

Corectitudinea algoritmului (5p)
Algoritmul prezentat NU este corect. Contraexemplu:


Considerăm un graf cu 3 noduri (1,2,3) și muchii:

(1,2) cu cost 10
(2,3) cu cost 1
(1,3) cu cost 2


Algoritmul va alege prima dată muchia (1,2) deoarece începe cu nodul 1
Apoi va alege (2,3)
Rezultatul va avea cost 11, dar soluția optimă are cost 3 folosind muchiile (1,3) și (2,3)

Problema este că algoritmul forțează alegerea unei muchii conectate la nodul curent i, ceea ce nu garantează optimalitatea globală.

Ford-Fulkerson (12.5p)
Aplicăm algoritmul Edmonds-Karp (Ford-Fulkerson cu BFS):

Pași:

Găsim drumul: 1-2-6-7 cu flux augmentant 3
Găsim drumul: 1-5-3-7 cu flux augmentant 3
Găsim drumul: 1-5-4-2-6-7 cu flux augmentant 2

Flux maxim = 8
Tăietura minimă:

S = {1,5}
T = {2,3,4,6,7}
Capacitatea tăieturii = 8 (suma capacităților arcelor care traversează tăietura)


Proprietăți ale grafurilor (15p)

a) Demonstrație că graful este conex:

Presupunem prin reducere la absurd că graful nu este conex
Există două componente conexe A și B
Fie x un nod din A și y un nod din B
x are grad ≥ n/2 în A
y are grad ≥ n/2 în B
Suma gradelor ≥ n, imposibil într-un graf cu n noduri
Contradicție, deci graful este conex

b) Exemplu de graf nehamiltonian:
Copy1 -- 2 -- 3
    |    |
    4 -- 5
Nodurile 1 și 5 au suma gradelor = 5 ≥ n = 5, dar graful nu este hamiltonian.
c) Demonstrație că graful este hamiltonian:

m ≥ (n-1)(n-2)/2 + 2
Folosind teorema lui Ore, dacă suma gradelor oricăror două noduri neadiacente ≥ n
Prin contradicție, dacă există noduri neadiacente cu suma gradelor < n
Numărul de muchii ar fi mai mic decât cel dat
Contradicție, deci graful este hamiltonian


Subsir comun maximal (7.5p)
Pentru cuvintele 'cerceta' și 'retea':

Matricea dp[][] calculată:
Copy    r  e  t  e  a
c   0  0  0  0  0
e   0  1  1  1  1
r   1  1  1  1  1
c   1  1  1  1  1
e   1  2  2  2  2
t   1  2  3  3  3
a   1  2  3  3  4
Lungimea maximă = 4
Un subsir comun maximal: 'etea'

Exploratorii în mină (15p)
Soluție:
Modelăm problema ca un graf orientat unde:

Nodurile sunt camerele
Arcele sunt tunelurile
Costul unui nod este cantitatea de dinamită necesară (0 sau 1)


Folosim algoritmul Dijkstra modificat:

Distanța = suma dinamitei necesare
Relaxăm muchiile considerând costul nodului destinație
Păstrăm un vector de predecesori pentru reconstrucția drumului


Complexitate: O((V+E)logV) unde:

V = numărul de camere
E = numărul de tuneluri


Drumul optim se poate reconstrui folosind vectorul de predecesori

Această soluție este optimă deoarece:

Folosește o coadă de priorități pentru a explora mai întâi drumurile cu cost minim
Garantează găsirea drumului care folosește minimum de dinamită
Are complexitate optimă pentru grafuri rare
