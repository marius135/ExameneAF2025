Examen la Algoritmi Fundamentali - Varianta 2
Data: 28.01.2025

Indicatii: Pentru subiectele 1-6 vecinii unui vârf se consideră în ordine lexicografică.

## Rezolvare:

**1. Subgraf indus bipartit conex cu număr maxim de noduri:**

Un subgraf indus bipartit conex cu număr maxim de noduri este format din nodurile {1, 2, 3, 4, 5, 6, 8, 9}  cu bipartiția  {1, 3, 4, 6, 9}, {2, 5, 8}.  Muchiile acestui subgraf sunt: (1,2), (1,3), (2,3), (2,6), (3,4), (3,5), (3,6), (4,5), (4,8), (8,9).  Acest subgraf este conex și are 8 noduri.  O altă variantă ar fi subgraful indus de nodurile {1, 2, 3, 4, 5, 6, 7, 8} cu bipartitia {1, 3, 4, 6}, {2, 5, 7, 8}.


**2. Parcurgerea în lățime bf(4):**

* **Initializare:** Se creează o coadă Q și se marchează toate nodurile ca nevizitate. Se adaugă nodul 4 în coadă și se marchează ca vizitat. Distanța d[4] = 0.
* **Iteratie:** Cât timp coada Q nu este vidă:
    * Se extrage primul element v din coadă.
    * Pentru fiecare vecin u al lui v (în ordine lexicografică):
        * Dacă u este nevizitat:
            * Se marchează u ca vizitat.
            * Se adaugă u în coada Q.
            * d[u] = d[v] + 1.

**Exemplu:**

* Q = {4}
* v = 4, vecini: 3, 5, 8
* Q = {3, 5, 8}, d[3]=1, d[5]=1, d[8]=1
* v = 3, vecini: 1, 2, 4, 5, 6
* Q = {5, 8, 1, 2, 6}, d[1]=2, d[2]=2, d[6]=2 (4, 5 deja vizitate)
* ... și așa mai departe

**Arbore BFS:** Radacina este 4.  Nodurile sunt adăugate la arbore în ordinea în care sunt vizitate. Muchiile arborelui sunt cele folosite pentru a ajunge la un nod nevizitat.

*(Desenati arborele BFS cu 4 ca radacină, conectat la 3, 5, 8, apoi 3 conectat la 1, 2, 6, etc.)*

**3. Lanț Eulerian:**

Graful nu admite un lanț eulerian deoarece are mai mult de două noduri cu grad impar (1, 2, 5, 6, 7, 9).

Pentru a obține un lanț eulerian, trebuie să eliminăm muchii astfel încât să rămână cel mult două noduri cu grad impar.  O strategie este eliminarea muchiilor (1,2) și (7,9).  Astfel, doar nodurile 5 și 6 rămân cu grad impar.

Un lanț eulerian în graful rezultat este: 5-3-1-3-4-8-7-8-4-3-2-6-3-6

**Condiție necesară și suficientă:** Un graf neorientat conex are un lanț eulerian dacă și numai dacă are exact 0 sau 2 noduri cu grad impar.

**4. Noduri critice:**

**Algoritm:**  Se folosește algoritmul Tarjan bazat pe DFS.  Pentru fiecare nod v, se calculează:

* `dfn[v]`: timpul de descoperire în DFS.
* `low[v]`: cel mai mic timp de descoperire dfn[u] accesibil din subarborele lui v prin muchii de întoarcere (back edges).

Un nod v este critic dacă și numai dacă există un fiu u al lui v în arborele DFS astfel încât low[u] >= dfn[v].

**Exemplu:** *(Aplicați algoritmul Tarjan pe graful dat. Descrieți pașii și rezultatele obținute pentru dfn și low. Identificați nodurile critice.)*  Nodul 3 este critic.


**5. Floyd-Warshall:**

**Initializare:**
content_copy
download
Use code with caution.

D[i][j] = w[i][j] dacă există muchia (i, j), infinit altfel
D[i][i] = 0 pentru orice i

**Algoritm:**
content_copy
download
Use code with caution.

pentru k ← 1, n execută
pentru i ← 1, n execută
pentru j ← 1, n execută
D[i][j] = min(D[i][j], D[i][k] + D[k][j])

**Exemplu:** *(Construiți matricea D inițială.  Calculați matricea D pentru j=1, j=2, j=3. Indicați ce valori se modifică la fiecare pas.)*


**6. Prim (pornind din 4):**

* Initializare:  Se creează un arbore T vid. Se alege nodul 4 ca rădăcină.
* Iteratie: Cât timp T nu conține toate nodurile:
    * Se alege muchia de cost minim (u, v) astfel încât u este în T și v nu este în T.
    * Se adaugă muchia (u, v) și nodul v la T.

**Exemplu:** *(Descrieți pașii algoritmului Prim pe graful dat pornind din nodul 4.)*


**7. Corectitudinea algoritmului:**

Algoritmul descris **nu** este corect.  Deși ideea de a adăuga muchii de cost minim este similară cu algoritmul lui Kruskal, acest algoritm nu garantează că rezultatul va fi un arbore parțial de cost minim.

**Contraexemplu:** *(Desenați un graf mic unde algoritmul descris produce un arbore parțial care nu este de cost minim. Explicați de ce arborele rezultat nu este de cost minim.)*

**8. Ford-Fulkerson (Edmonds-Karp):**

*(Ilustrați pașii algoritmului Edmonds-Karp pe rețeaua dată.  Indicați la fiecare pas lanțul f-nesaturat ales și cum se modifică fluxul.  Indicați o tăietură minimă și capacitatea acesteia.)*

**9. Demonstrații:**

**(a) Graf cu d(x) >= n/2:**
Presupunem că graful nu este conex. Atunci există cel puțin două componente conexe. Fie C1 și C2 două astfel de componente.  Fie n1 și n2 numărul de noduri din C1 și C2, respectiv.  Fie x un nod din C1. Atunci d(x) <= n1 - 1.  Deoarece d(x) >= n/2, avem n1 - 1 >= n/2.  Similar, pentru un nod y din C2, avem n2 - 1 >= n/2.  Adunând cele două inegalități, obținem n1 + n2 - 2 >= n.  Dar n1 + n2 <= n, ceea ce este o contradicție.  Deci graful trebuie să fie conex.


**(b) Graf nehamiltonian:**
Un graf cu n = 5 noduri, format din ciclul C4 (1,2,3,4) și un nod izolat 5. Suma gradelor nodurilor 1 și 5 este 2 + 0 = 2, care este mai mică decât 5. Adăugam muchia (1,5). Graful rezultat este nehamiltonian, iar suma gradelor nodurilor 1 și 3 este 3+2=5 >=5.


**(c) Graf cu m >= C(n-1, 2) + 2 muchii:** *(Demonstrația se face prin inducție. Cazul de bază n=3 este trivial. Pasul de inducție se face prin demonstrarea existenței unui nod x cu d(x) < n/2, contrar teoremei lui Ore.)*


**10. Subșir comun maxim:**

**Algoritm:** Se folosește programare dinamică.  Se construiește o matrice L[i][j] unde L[i][j] este lungimea maximă a unui subșir comun a prefixelor de lungime i și j ale celor două cuvinte.

**Relația de recurență:**

* L[i][0] = L[0][j] = 0
* L[i][j] = L[i-1][j-1] + 1 dacă a[i] = b[j]
* L[i][j] = max(L[i-1][j], L[i][j-1]) dacă a[i] != b[j]

**Exemplu:** *(Construiți matricea L pentru cuvintele "cerceta" și "retea". Explicați cum a fost calculată fiecare valoare din matrice.)*


**11. Drum în mina subterană:**

Se poate modela problema ca o problemă de drum minim într-un graf orientat ponderat.  Camerele minei sunt nodurile grafului, iar tunelurile sunt muchiile.  Costul unei muchii este 0 dacă tunelul corespunzător nu este prăbușit și 1 altfel.  Se poate folosi algoritmul Dijkstra pentru a găsi drumul de cost minim de la camera de intrare la camera cu cristalul.  Costul drumului minim va reprezenta numărul minim de camere prăbușite pe care trebuie să le traverseze exploratorii.
content_copy
download
Use code with caution.
content_copy
download
Use code with caution.