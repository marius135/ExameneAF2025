
**Exemplu:** *(Construiți matricea D inițială.  Calculați matricea D pentru j=1, j=2, j=3. Indicați ce valori se modifică la fiecare pas.)*


**6. Prim (pornind din 4):**

* Initializare:  Se creează un arbore T vid. Se alege nodul 4 ca rădăcină.
* Iteratie: Cât timp T nu conține toate nodurile:
    * Se alege muchia de cost minim (u, v) astfel încât u este în T și v nu este în T.
    * Se adaugă muchia (u, v) și nodul v la T.

**Exemplu:** *(Descrieți pașii algoritmului Prim pe graful dat pornind din nodul 4.)*


**7. Corectitudinea algoritmului:**

Algoritmul descris **nu** este corect.  Deși ideea de a adăuga muchii de cost minim este similară cu algoritmul lui Kruskal, acest algoritm nu garantează că rezultatul va fi un arbore parțial de cost minim.

**Contraexemplu:** *(Desenați un graf mic unde algoritmul descris produce un arbore parțial care nu este de cost minim. Explicați de ce arborele rezultat nu este de cost minim.)*

**8. Ford-Fulkerson (Edmonds-Karp):**

*(Ilustrați pașii algoritmului Edmonds-Karp pe rețeaua dată.  Indicați la fiecare pas lanțul f-nesaturat ales și cum se modifică fluxul.  Indicați o tăietură minimă și capacitatea acesteia.)*

**9. Demonstrații:**

**(a) Graf cu d(x) >= n/2:**
Presupunem că graful nu este conex. Atunci există cel puțin două componente conexe. Fie C1 și C2 două astfel de componente.  Fie n1 și n2 numărul de noduri din C1 și C2, respectiv.  Fie x un nod din C1. Atunci d(x) <= n1 - 1.  Deoarece d(x) >= n/2, avem n1 - 1 >= n/2.  Similar, pentru un nod y din C2, avem n2 - 1 >= n/2.  Adunând cele două inegalități, obținem n1 + n2 - 2 >= n.  Dar n1 + n2 <= n, ceea ce este o contradicție.  Deci graful trebuie să fie conex.


**(b) Graf nehamiltonian:**
Un graf cu n = 5 noduri, format din ciclul C4 (1,2,3,4) și un nod izolat 5. Suma gradelor nodurilor 1 și 5 este 2 + 0 = 2, care este mai mică decât 5. Adăugam muchia (1,5). Graful rezultat este nehamiltonian, iar suma gradelor nodurilor 1 și 3 este 3+2=5 >=5.


**(c) Graf cu m >= C(n-1, 2) + 2 muchii:** *(Demonstrația se face prin inducție. Cazul de bază n=3 este trivial. Pasul de inducție se face prin demonstrarea existenței unui nod x cu d(x) < n/2, contrar teoremei lui Ore.)*


**10. Subșir comun maxim:**

**Algoritm:** Se folosește programare dinamică.  Se construiește o matrice L[i][j] unde L[i][j] este lungimea maximă a unui subșir comun a prefixelor de lungime i și j ale celor două cuvinte.

**Relația de recurență:**

* L[i][0] = L[0][j] = 0
* L[i][j] = L[i-1][j-1] + 1 dacă a[i] = b[j]
* L[i][j] = max(L[i-1][j], L[i][j-1]) dacă a[i] != b[j]

**Exemplu:** *(Construiți matricea L pentru cuvintele "cerceta" și "retea". Explicați cum a fost calculată fiecare valoare din matrice.)*


**11. Drum în mina subterană:**

Se poate modela problema ca o problemă de drum minim într-un graf orientat ponderat.  Camerele minei sunt nodurile grafului, iar tunelurile sunt muchiile.  Costul unei muchii este 0 dacă tunelul corespunzător nu este prăbușit și 1 altfel.  Se poate folosi algoritmul Dijkstra pentru a găsi drumul de cost minim de la camera de intrare la camera cu cristalul.  Costul drumului minim va reprezenta numărul minim de camere prăbușite pe care trebuie să le traverseze exploratorii.