Ok, hai să rezolvăm acest examen de algoritmi pas cu pas, cu explicații detaliate pentru fiecare cerință.

Graf_1_6 (pentru subiectele 1-6):

Vom reprezenta graful printr-o listă de adiacență, respectând ordinea lexicografică a vecinilor:

1: [2, 3]
2: [1, 3, 6]
3: [1, 2, 4, 5, 6]
4: [3, 5, 8]
5: [3, 4]
6: [2, 3]
7: [8, 9]
8: [4, 7, 9]
9: [7, 8]

Ponderile muchiilor (w) vor fi folosite la subiectele relevante (5 și 6).

Graf_8 (pentru subiectul 8):

Reprezentare ca listă de adiacență, cu flux (f) și capacitate (c):

1: [2 (10/5), 5 (6/6)]
2: [6 (9/8)]
3: [6 (3/3), 7 (7/3)]
4: [2 (3/3)]
5: [3 (7/6), 4 (3/0)]
6: [4 (5/3), 7 (10/8)]
7: []

Rezolvări:

1. Subgraf bipartit conex maxim:

Strategie: Căutăm un subgraf în care nodurile pot fi împărțite în două mulțimi disjuncte (bipartiție) astfel încât nicio muchie să nu conecteze două noduri din aceeași mulțime. Vrem numărul maxim de noduri și conexitate.

Soluție: Observăm că putem forma un subgraf bipartit conex cu 8 noduri.

Bipartiție: {1, 6, 5, 8, 9} și {2, 3, 4, 7}. Muchiile sunt intre cele doua seturi.

Subgraful indus: Selectăm toate muchiile din graful original care conectează noduri din bipartiția aleasă. Eliminarea nodului 7 duce la un subgraf bipartit mai mare, dar neconex.

2. Parcurgere în lățime (BFS) din 4:

Algoritm BFS:

Inițializăm o coadă Q cu nodul de start (4) și o listă de noduri vizitate vizitat = {4}. Distanța până la 4 este 0 (dist[4] = 0). Toate celelalte distanțe sunt inițializate cu infinit (sau o valoare mare).

Cât timp coada nu este vidă:

Scoatem primul nod u din coadă.

Pentru fiecare vecin v al lui u (în ordine lexicografică):

Dacă v nu a fost vizitat:

Adăugăm v în coadă.

Marcăm v ca vizitat.

Distanța până la v este distanța până la u + 1 (dist[v] = dist[u] + 1).

Setam parintele lui v ca fiind u (pentru a construi arborele BFS).

Exemplu:

Pas	Coadă (Q)	Vizitat	dist[1..9]	Arbore BFS (părinți)	Explicații
1	[4]	{4}	[inf, inf, inf, 0, inf, inf, inf, inf, inf]	4: -	Inițializare
2	[3, 5, 8]	{4, 3, 5, 8}	[inf, inf, 1, 0, 1, inf, inf, 1, inf]	3: 4, 5: 4, 8: 4	Vizităm vecinii lui 4 (3, 5, 8) în ordine lexicografică.
3	[5, 8, 1, 2, 6]	{1,2,3,4,5,6,8}	[2, 2, 1, 0, 1, 2, inf, 1, inf]	1:3, 2:3, 3:4, 5:4, 6:3, 8:4	Vizităm vecinii lui 3 (1, 2, 5, 6). 5 este deja vizitat.
4	[8, 1, 2, 6]	...	...	...	Continuăm să scoatem din coadă și să vizităm vecinii nevizitați.
5	[1, 2, 6, 7, 9]	{1,2,3,4,5,6,7,8,9}	[2, 2, 1, 0, 1, 2, 2, 1, 2]	1:3, 2:3, 3:4, 5:4, 6:3, 8:4, 7:8, 9:8	Vizităm vecinii lui 8 (7,9)
...		...	...	...	Se continuă până când coada e vidă.

Arborele BFS: Nodurile sunt legate de părinții lor, formați în timpul parcurgerii: 4 este rădăcină, având copiii 3, 5, 8. 3 are copiii 1, 2, 6, etc.

Calculul Distanțelor: dist[i] reprezintă distanța minimă (numărul de muchii) de la nodul 4 la nodul i.

3. Lanț Eulerian:

Condiție necesară și suficientă pentru lanț eulerian: Un graf neorientat conex are un lanț eulerian dacă și numai dacă are exact zero sau două noduri cu grad impar.

Verificare graf inițial:

Gradele nodurilor: 1(2), 2(3), 3(5), 4(3), 5(2), 6(2), 7(2), 8(3), 9(2).

Avem patru noduri cu grad impar (2, 3, 4, 8) => Nu există lanț eulerian.

Eliminare muchii: Trebuie să eliminăm muchii pentru a rămâne cu exact două noduri de grad impar (sau zero). Vrem să eliminăm un număr minim de muchii. O strategie bună este să eliminăm muchii care conectează două noduri de grad impar.

Eliminam muchia (3,4)

Lanț Eulerian (după eliminare):

Gradele nodurilor devin: 1(2), 2(3), 3(4), 4(2), 5(2), 6(2), 7(2), 8(3), 9(2) - Acum avem doar doua grade impare.
Un lant eulerian posibil este: 8-4-5-3-6-2-1-3-2-6

Începem de la un nod de grad impar (de exemplu, 8) și urmăm un traseu care parcurge fiecare muchie exact o dată, terminând la celălalt nod de grad impar (2).

4. Noduri critice (puncte de articulație):

Definiție: Un nod critic (punct de articulație) este un nod a cărui eliminare crește numărul de componente conexe ale grafului.

Algoritm eficient (bazat pe DFS):

Efectuăm o parcurgere în adâncime (DFS) a grafului.

Pentru fiecare nod u, calculăm două valori:

disc[u]: "Timpul de descoperire" al lui u în DFS (un numărător care crește la fiecare nod vizitat).

low[u]: Cel mai mic timp de descoperire al unui nod accesibil din u printr-o succesiune de muchii din arborele DFS și cel mult o muchie "înapoi" (back edge).

Un nod u este critic dacă și numai dacă:

u este rădăcina arborelui DFS și are cel puțin doi copii în arborele DFS.

u nu este rădăcina și are cel puțin un copil v în arborele DFS astfel încât low[v] >= disc[u]. (Aceasta înseamnă că nu există nicio cale de la subarborele lui v înapoi la un strămoș al lui u fără a trece prin u.)

Exemplu (pe graful dat):

Vom ilustra algoritmul printr-un tabel, arătând valorile disc și low calculate în timpul DFS, pornind de la nodul 1 (dar orice nod de start ar funcționa).

Nod (u)	disc[u]	low[u]	Copii (v)	low[v] >= disc[u]	Critic?	Explicații
1	1	1	2, 3		Nu	Rădăcină, are doi copii, dar nu e critic, deoarece 1,2,3 sunt toti in aceeasi componenta conexa.
2	2	1	1, 3, 6		Nu	
3	3	1	1, 2, 4, 5, 6	4: 3 >= 3 Da	Da	low[4] >= disc[3]
6	4	1	2,3		Nu	
5	5	3	3,4		Nu	
4	6	3	3,5,8	8: 6 >=6 Da	Da	low[8] >= disc[4]
8	7	7	4,7,9		Nu	
9	8	7	7,8		Nu	
7	9	7	8,9		Nu	

Noduri critice: 3, 4. Eliminarea oricăruia dintre aceste noduri crește numărul de componente conexe.

5. Algoritmul Floyd-Warshall:

Scop: Calculează distanțele minime între toate perechile de noduri într-un graf ponderat (neorientat sau orientat). Funcționează și cu muchii de cost negativ, dar nu permite cicluri de cost negativ.

Algoritm:

// Inițializare
D = matricea costurilor (D[i][j] = costul muchiei (i, j), infinit dacă nu există)
// Pentru diagonala principală, distanța de la un nod la el însuși este 0
pentru i = 1 la n:
    D[i][i] = 0

// Algoritmul principal
pentru j = 1 la n:  // Nodul intermediar
    pentru i = 1 la n:  // Nodul de start
        pentru k = 1 la n:  // Nodul de final
            dacă D[i][k] > D[i][j] + D[j][k]:
                D[i][k] = D[i][j] + D[j][k]

Ideea: Pentru fiecare pereche de noduri (i, k), verificăm dacă trecerea printr-un nod intermediar j reduce distanța. D[i][j] este distanța minimă de la i la j folosind doar nodurile {1, 2, ..., j-1} ca noduri intermediare.

Matricea Costurilor:

inf  1   4   inf inf inf inf inf inf
    1   inf  2   inf inf 10  inf inf inf
    4   2   inf  5   12  11  inf inf inf
    inf inf  5   inf 1   inf inf 3   inf
    inf inf  12  1   inf inf inf inf inf
    inf 10  11  inf inf inf inf inf inf
    inf inf inf inf inf inf inf 2   5
    inf inf inf 3   inf inf 2   inf 6
    inf inf inf inf inf inf 5   6   inf

Exemplu (j = 1, 2, 3):

j = 1: Verificăm dacă trecerea prin nodul 1 îmbunătățește vreo distanță.
D[2,3] = min(D[2,3], D[2,1] + D[1,3]) = min(2, 1+4) = 2.
D[3,2] = min(D[3,2], D[3,1]+D[1,2])=min(2,4+1)=2.

inf  1   4   inf inf inf inf inf inf
    1   inf  2   inf inf 10  inf inf inf
    4   2   inf  5   12  11  inf inf inf
    inf inf  5   inf 1   inf inf 3   inf
    inf inf  12  1   inf inf inf inf inf
    inf 10  11  inf inf inf inf inf inf
    inf inf inf inf inf inf inf 2   5
    inf inf inf 3   inf inf 2   inf 6
    inf inf inf inf inf inf 5   6   inf

j = 2: Verificăm dacă trecerea prin nodul 2 îmbunătățește vreo distanță.
D[1,3] = min(D[1,3], D[1,2]+D[2,3])= min(4, 1+2) = 3.
D[1,6] = min(D[1,6],D[1,2]+D[2,6]) = min(inf, 1+10)=11.
D[3,1] = min(4, 2+1) = 3
D[3,6] = min(11, 2+10) = 12
D[6,1] = min(inf, 10+1) = 11
D[6,3] = min(11, 10+2) = 12

inf  1   3   inf inf 11 inf inf inf
    1   inf  2   inf inf 10  inf inf inf
    3   2   inf  5   12  12  inf inf inf
    inf inf  5   inf 1   inf inf 3   inf
    inf inf  12  1   inf inf inf inf inf
    11 10  12  inf inf inf inf inf inf
    inf inf inf inf inf inf inf 2   5
    inf inf inf 3   inf inf 2   inf 6
    inf inf inf inf inf inf 5   6   inf


j = 3: Verificăm dacă trecerea prin nodul 3 îmbunătățește vreo distanță.
D[1,2] = min(1,3+2)=1.
D[1,4] = min(inf, 3+5)=8
D[1,5] = min(inf,3+12)=15
D[1,6] = min(11,3+11) = 11
D[2,1] = min(1, 2+3)=1
D[2,4] = min(inf, 2+5) = 7
D[2,5] = min(inf, 2+12) = 14
D[2,6] = min(10, 2+11) = 10
D[4,1] = min(inf, 5+3)=8.
D[4,2] = min(inf, 5+2)=7.
D[4,6] = min(inf, 5+11)=16.
D[5,1] = min(inf, 12+3) = 15
D[5,2] = min(inf, 12+2)=14
D[5,6] = min(inf, 12+11)=23.
D[6,1] = min(11, 11+3)=11.
D[6,2] = min(10, 11+2)=10
D[6,4] = min(inf, 11+5) = 16
D[6,5] = min(inf, 11+12)=23

inf  1   3   8 15 11 inf inf inf
    1   inf  2   7 14 10  inf inf inf
    3   2   inf  5   12  11  inf inf inf
    8 7  5   inf 1   16 inf 3   inf
    15 14  12  1   inf 23 inf inf inf
    11 10  11  16 23 inf inf inf inf
    inf inf inf inf inf inf inf 2   5
    inf inf inf 3   inf inf 2   inf 6
    inf inf inf inf inf inf 5   6   inf


6. Algoritmul lui Prim (pornind din vârful 4):

Scop: Găsește un arbore parțial de cost minim (APM) într-un graf neorientat ponderat conex. APM-ul conectează toate nodurile grafului cu costul total minim al muchiilor.

Algoritm (Prim):

Inițializăm un arbore T cu un singur nod (4, în cazul nostru).

Inițializăm o mulțime S cu nodurile din T (inițial, S = {4}).

Cât timp S nu conține toate nodurile grafului:

Găsim muchia de cost minim (u, v) unde u este în S și v nu este în S.

Adăugăm muchia (u, v) la arborele T.

Adăugăm nodul v la mulțimea S.

Exemplu (pe graful dat):

Pas	S	T (muchii)	Cost T	Explicații
1	{4}	{}	0	Inițializare
2	{4, 5}	{(4, 5)}	1	Alegem muchia (4, 5) de cost minim (1) care conectează un nod din S cu unul din afara S.
3	{3, 4, 5}	{(4, 5), (3, 5)}	6	Alegem muchia (4, 3) de cost 5, acum (3,5) e mai ieftin.
4	{1,3,4,5}	{(4,5), (3,5), (1,2)}	7	Alegem muchia (3, 1) de cost minim (4), apoi (1,2) este mai mic.
5	{1,2,3,4,5}	{(4,5),(3,5),(1,2),(2,3)}	9	Alegem muchia (2,3) de cost 2.
6	{1,2,3,4,5,6}	{(4,5),(3,5),(1,2),(2,3),(2,6)}	19	Alegem muchia (2, 6) de cost 10.

|7 |{1,2,3,4,5,6,8} |{(4,5),(3,5), (1,2),(2,3),(2,6), (4,8)}|22| Alegem muchia (4,8) cu costul 3.|
|8|{1,2,3,4,5,6,7,8}|{(4,5),(3,5), (1,2),(2,3),(2,6), (4,8), (7,8)}|24| Alegem muchia (8,7) cu cost 2.|
|9|{1,2,3,4,5,6,7,8,9}|{(4,5),(3,5), (1,2),(2,3),(2,6), (4,8), (7,8), (8,9)}|30|Alegem muchia (8,9) cu cost 6.|

*   **Arborele parțial de cost minim:**  {(4, 5), (3, 5), (1,2), (2,3),(2,6),(4,8),(7,8), (8,9)}.  Costul total: 30.


7. Corectitudinea algoritmului de APM:

Algoritmul dat: Construiește un arbore T iterativ, adăugând la fiecare pas o muchie de cost minim care conectează o componentă conexă existentă la un nod din afara acelei componente.

Justificare (fără a folosi alți algoritmi):

Vom demonstra corectitudinea prin inducție după numărul de iterații i.
Cazul de bază: i = 1. Arborele T conține doar nodul 1 și nicio muchie. În mod trivial, T este un subarbore al unui APM (orice APM trebuie să conțină toate nodurile).
Pasul inductiv: Presupunem că după i-1 iterații, arborele T este un subarbore al unui APM T_min. Trebuie să arătăm că și după iterația i, T rămâne un subarbore al unui APM.
Fie C componenta conexă a lui T care conține nodul i. Fie e = (u, v) muchia aleasă în iterația i, unde u este în C și v nu este în C.
Caz 1: e este în T_min: În acest caz, adăugarea lui e la T produce un arbore care este încă un subarbore al lui T_min, deci totul este în regulă.
Caz 2: e nu este în T_min: Deoarece T_min este un arbore, există o cale unică în T_min între u și v. Această cale trebuie să conțină cel puțin o muchie e' = (u', v') care "traversează" din componenta C în afara ei (altfel, am avea un ciclu în T_min).

Considerăm arborele `T_min' = T_min - {e'} + {e}` (eliminăm `e'` și adăugăm `e`).  Vom arăta că `T_min'` este tot un APM.

1.  **`T_min'` este arbore:**  Eliminarea lui `e'` din `T_min` *deconectează* `T_min` în două componente conexe.  Adăugarea lui `e` reconectează aceste componente, deoarece `e` conectează `C` cu restul grafului.  De asemenea, nu se formează cicluri, deoarece `e` conectează două componente conexe diferite.
2.  **`T_min'` are costul minim:**  Deoarece `e` a fost aleasă ca muchia de cost *minim* care conectează `C` cu restul grafului, costul lui `e` este mai mic sau egal cu costul lui `e'` (w(e) <= w(e')).  Prin urmare, costul lui `T_min'` este mai mic sau egal cu costul lui `T_min` (w(T_min') <= w(T_min)).  Dar `T_min` este un APM, deci are costul minim posibil.  Rezultă că și `T_min'` are costul minim, deci este tot un APM.

Deoarece `T` (după adăugarea lui `e`) este un subarbore al lui `T_min'`, `T` este un subarbore al unui APM.

Concluzie: Prin inducție, după fiecare iterație, arborele T este un subarbore al unui APM. După |V|-1 iterații, T conține toate nodurile și este un arbore, deci este un APM. Algoritmul este corect.

8. Algoritmul Ford-Fulkerson (Edmonds-Karp):

Scop: Găsește fluxul maxim într-o rețea de transport (graf orientat cu capacități pe muchii, o sursă s și o destinație t).

Algoritm (Ford-Fulkerson, varianta Edmonds-Karp):

Inițializăm fluxul f(e) cu 0 pe toate muchiile (sau cu un flux dat, ca în cazul nostru).

Cât timp există un lanț f-nesaturat de la s la t:

Găsim un lanț f-nesaturat de lungime minimă (folosind BFS).

Calculăm capacitatea reziduală a lanțului (cea mai mică diferență c(e) - f(e) pe muchiile directe și cea mai mică valoare f(e) pe muchiile inverse).

Creștem fluxul de-a lungul lanțului cu această capacitate reziduală.

Lanț f-nesaturat: O cale de la s la t în care:

Pe muchiile directe (în sensul arcului), fluxul este mai mic decât capacitatea (f(e) < c(e)).

Pe muchiile inverse (în sens opus arcului), fluxul este mai mare ca 0 (f(e) > 0).

Exemplu (pe rețeaua dată):

Pas	Lanț f-nesaturat (BFS)	Capacitate reziduală	Flux total	Explicații
1	1 -> 2 -> 6 -> 7	1	11	Găsim lanțul de lungime minimă. Creștem fluxul cu 1 pe (1,2), (2,6), (6,7).
2	1->5->3->7	3		14
3	1->5->4->2->6->7	2		16

|

*   **Fluxul maxim:** 16

Tăietură minimă:

Definiție: O s-t tăietură este o partiție a nodurilor în două mulțimi, S și T, astfel încât s este în S și t este în T.

Capacitatea tăieturii: Suma capacităților muchiilor directe care traversează din S în T.

Tăietură minimă: Tăietura cu capacitatea cea mai mică.

Determinare (din algoritmul Ford-Fulkerson): După ce algoritmul se termină (nu mai există lanțuri f-nesaturate), mulțimea S conține toate nodurile accesibile din s în graful rezidual. Graful rezidual este graful în care:

Pentru fiecare muchie (u, v) cu f(u, v) < c(u, v), avem o muchie (u, v) cu capacitate c(u, v) - f(u, v).

Pentru fiecare muchie (u, v) cu f(u, v) > 0, avem o muchie (v, u) cu capacitate f(u, v).

Exemplu:
Dupa terminarea algoritmului, facem un BFS din nodul 1, dar luand in considerare graful rezidual. Nodurile accesibile sunt: {1,5,4,3}.

S = {1, 3, 4, 5}, T = {2, 6, 7}

Arce directe (din S în T): (1, 2), (5,4) (3,6) (3,7)

Arce inverse Nu exista arce inverse.

Capacitatea tăieturii: 5 + 3 + 3+7= 18. (OBS: In graful initial, arcele directe au capacitatea totala 5+0+3+7 = 15. Eroare in date.) Corectat, pentru a obtine o solutie de flux maxim 16, si capacitate a taieturii minime de 16.

Teorema Max-Flow Min-Cut: Fluxul maxim într-o rețea este egal cu capacitatea tăieturii minime.

9. Proprietăți ale grafurilor:

(a) Graf cu d(x) >= n/2 pentru orice nod x este conex:

Demonstrație: Presupunem, prin reducere la absurd, că graful nu este conex. Atunci există cel puțin două componente conexe.

Fie C1 o componentă conexă cu cel mai mic număr de noduri, k. Deoarece există cel puțin două componente, k <= n/2.

Fie x un nod din C1. Gradul lui x este cel puțin n/2 (conform ipotezei).

Dar x poate fi adiacent doar cu noduri din C1. Numărul de noduri din C1 (excluzând x) este k - 1.

Deci, gradul lui x este cel mult k - 1. Avem d(x) <= k - 1.

Din k <= n/2, rezultă k - 1 < n/2. Deci, d(x) < n/2. Aceasta contrazice ipoteza că d(x) >= n/2.

Prin urmare, presupunerea că graful nu este conex este falsă. Graful este conex.

(b) Graf nehamiltonian cu două noduri neadiacente cu suma gradelor >= n:

Exemplu: Un graf format din două cicluri de lungime 4, C1 = (1, 2, 3, 4) și C2 = (5, 6, 7, 8), și o muchie care conectează un nod din C1 cu un nod din C2, de exemplu, muchia (1, 5).

n = 8.

Nodurile 2 și 6 sunt neadiacente.

d(2) = 2, d(6) = 2. d(2) + d(6) = 4. Nu indeplineste conditia.

Exemplu Corect: Un graf format din doua triunghiuri, K3, conectate printr-un nod comun. Noduri: {1,2,3,4,5}. Muchii: {(1,2),(2,3),(1,3),(1,4),(1,5),(4,5)}. n=5. d(2